{{template "base" .}}

{{define "content"}}
<div class="home-container">
    <div class="page-header">
        <div class="header-left">
            <button class="notification-btn" id="notificationBtn" onclick="openNotifications()" title="Notifications">
                <img src="/icon/bell" class="notification-icon" alt="Notifications">
                <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
            </button>
        </div>
        <div class="header-actions">
            <a href="/calendar" class="page-nav-btn"><img src="/icon/calendar-days" class="nav-icon" alt="">Calendar</a>
            <button class="settings-btn" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
            </button>
        </div>
    </div>
    {{if or .Groups .Cameras}}
    <div class="groups-grid">
        {{range $idx, $group := .Groups}}
        <div class="group-card" onclick="openGroupModal('{{$group.Name}}')" data-group="{{$group.Name}}">
            <div class="group-card-icon">{{if eq $group.Name "Tesla"}}<img src="/icon/tesla-svgrepo-com" class="group-icon group-icon-tesla" alt="">{{else if eq $group.Name "Security"}}<img src="/icon/lock" class="group-icon" alt="">{{else if eq $group.Name "Home"}}<img src="/icon/house-chimney" class="group-icon" alt="">{{else if eq $group.Name "Climate"}}<img src="/icon/temperature-high" class="group-icon" alt="">{{else if eq $group.Name "Lights"}}<img src="/icon/lightbulb" class="group-icon" alt="">{{else}}{{$group.Icon}}{{end}}</div>
            <div class="group-card-info">
                <div class="group-card-name">{{$group.Name}}</div>
                <div class="group-card-summary" id="summary-{{$group.Name}}">
                    {{len $group.Cards}} device{{if ne (len $group.Cards) 1}}s{{end}}
                </div>
            </div>
            <div class="group-card-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"/>
                </svg>
            </div>
        </div>
        {{end}}
        <!-- Hue Lights Card -->
        <div class="group-card" onclick="openHueModal()" data-group="Hue">
            <div class="group-card-icon"><img src="/icon/lightbulb" class="group-icon" alt=""></div>
            <div class="group-card-info">
                <div class="group-card-name"><img src="/icon/philipshue-svgrepo-com" class="hue-logo" alt="Philips Hue"></div>
                <div class="group-card-summary" id="summary-Hue">Loading...</div>
            </div>
            <div class="group-card-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"/>
                </svg>
            </div>
        </div>
        <!-- Spotify Card -->
        <div class="group-card" onclick="openSpotifyModal()" data-group="Spotify" id="spotifyCard" style="display: none;">
            <div class="group-card-icon"><img src="/icon/spotify" class="group-icon group-icon-spotify" alt=""></div>
            <div class="group-card-info">
                <div class="group-card-name">Spotify</div>
                <div class="group-card-summary" id="summary-Spotify">Not playing</div>
            </div>
            <div class="group-card-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"/>
                </svg>
            </div>
        </div>
    </div>

    <!-- Hidden data for JavaScript -->
    <script id="groupsData" type="application/json">
    {{range $idx, $group := .Groups}}
    {{if $idx}},{{end}}
    {"name": "{{$group.Name}}", "icon": "{{$group.Icon}}", "cards": [
        {{range $cidx, $card := $group.Cards}}
        {{if $cidx}},{{end}}
        {
            "entityId": "{{$card.EntityID}}",
            "name": "{{$card.Name}}",
            "state": "{{$card.State}}",
            "icon": "{{$card.Icon}}",
            "type": "{{$card.Type}}",
            "unit": "{{$card.Unit}}",
            "isOn": {{$card.IsOn}},
            "isLightGroup": {{$card.IsLightGroup}},
            "members": [{{range $midx, $member := $card.Members}}{{if $midx}},{{end}}{
                "entityId": "{{$member.EntityID}}",
                "name": "{{$member.Name}}",
                "state": "{{$member.State}}",
                "icon": "{{$member.Icon}}",
                "type": "{{$member.Type}}",
                "isOn": {{$member.IsOn}}
            }{{end}}],
            "attributes": {{if $card.Attributes}}{{ $card.Attributes | json }}{{else}}{}{{end}}
        }
        {{end}}
    ]}
    {{end}}
    </script>
    <script id="camerasData" type="application/json">
    [{{range $idx, $cam := .Cameras}}{{if $idx}},{{end}}{"name": "{{$cam.name}}", "label": "{{$cam.label}}"}{{end}}]
    </script>
    {{else}}
    <div class="no-cards">
        <p>No entities configured.</p>
        <p>Set HA_ENTITIES in your environment.</p>
    </div>
    {{end}}
</div>

<!-- Group Modal -->
<div id="groupModal" class="modal">
    <div class="modal-content modal-group">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <span id="groupModalIcon" class="group-modal-icon"></span>
                <h3 id="groupModalTitle"></h3>
            </div>
            <button class="modal-close-btn" onclick="closeGroupModal()">&times;</button>
        </div>
        <div id="groupModalContent" class="group-modal-content">
            <!-- Entities will be rendered here -->
        </div>
    </div>
</div>

<!-- Cameras Modal -->
<div id="camerasModal" class="modal">
    <div class="modal-content modal-cameras">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/video" class="group-modal-icon-img" alt="">
                <h3>Cameras</h3>
            </div>
            <button class="modal-close-btn" onclick="closeCamerasModal()">&times;</button>
        </div>
        <div id="camerasModalContent" class="cameras-modal-content">
            <!-- Cameras will be rendered here -->
        </div>
    </div>
</div>

<!-- Camera View Modal -->
<div id="cameraViewModal" class="modal camera-view-modal">
    <div class="modal-content modal-camera-view">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/video" class="group-modal-icon-img" alt="">
                <h3 id="cameraViewTitle">Camera</h3>
            </div>
            <button class="modal-close-btn" onclick="closeCameraViewModal()">&times;</button>
        </div>
        <div class="camera-view-container">
            <img id="cameraViewStream" class="camera-view-stream" alt="Camera stream">
            <div class="camera-view-loading">Loading camera...</div>
        </div>
        <div class="camera-view-actions">
            <button class="modal-btn secondary" onclick="closeCameraViewModal()">Close</button>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal">
    <div class="modal-content modal-settings">
        <h3 class="modal-header">Settings</h3>

        <div class="settings-section">
            <h4 class="settings-section-title">Appearance</h4>
            <div class="form-group">
                <label>Theme</label>
                <div class="theme-options">
                    <button type="button" class="theme-option" data-theme="light" onclick="setTheme('light')">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="5"/>
                            <line x1="12" y1="1" x2="12" y2="3"/>
                            <line x1="12" y1="21" x2="12" y2="23"/>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                            <line x1="1" y1="12" x2="3" y2="12"/>
                            <line x1="21" y1="12" x2="23" y2="12"/>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                        </svg>
                        <span>Light</span>
                    </button>
                    <button type="button" class="theme-option active" data-theme="dark" onclick="setTheme('dark')">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                        <span>Dark</span>
                    </button>
                    <button type="button" class="theme-option" data-theme="auto" onclick="setTheme('auto')">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 2a10 10 0 0 1 0 20"/>
                        </svg>
                        <span>Auto</span>
                    </button>
                </div>
            </div>
            <div class="form-group">
                <label>Time Format</label>
                <div class="time-format-toggle">
                    <button type="button" class="format-btn" data-format="12" onclick="setTimeFormat('12')">
                        12-Hour
                    </button>
                    <button type="button" class="format-btn active" data-format="24" onclick="setTimeFormat('24')">
                        24-Hour
                    </button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h4 class="settings-section-title">Weather</h4>
            <div class="settings-info">
                {{if .WeatherConfigured}}
                <div class="weather-status connected">
                    <span class="status-dot"></span>
                    <span>Weather data enabled</span>
                </div>
                {{else}}
                <div class="weather-status disconnected">
                    <span class="status-dot"></span>
                    <span>Not configured</span>
                </div>
                <p class="settings-hint">Add OPENWEATHER_API_KEY to .env to enable weather features like sunrise/sunset times and moon phases.</p>
                {{end}}
            </div>
        </div>

        <div class="settings-section">
            <h4 class="settings-section-title">About</h4>
            <p class="settings-hint">Home Control Kiosk v1.0</p>
        </div>

        <div class="modal-actions">
            <button type="button" class="modal-btn primary" onclick="closeSettings()">Done</button>
        </div>
    </div>
</div>

<!-- Hue Lights Modal (Full Screen) -->
<div id="hueModal" class="modal hue-modal">
    <div class="modal-content modal-hue-fullscreen">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/philipshue-svgrepo-com" class="hue-logo-modal" alt="Philips Hue">
                <img src="/icon/lightbulb" class="modal-header-lightbulb" alt="">
            </div>
            <button class="modal-close-btn" onclick="closeHueModal()">&times;</button>
        </div>
        <div id="hueModalContent" class="hue-modal-content">
            <div class="hue-loading">Loading lights...</div>
        </div>
    </div>
</div>

<!-- Spotify Modal (Full Screen) -->
<div id="spotifyModal" class="modal spotify-modal">
    <div class="modal-content modal-spotify-fullscreen">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/spotify" class="spotify-logo-modal" alt="Spotify">
                <h3>Spotify</h3>
            </div>
            <button class="modal-close-btn" onclick="closeSpotifyModal()">&times;</button>
        </div>
        <div id="spotifyModalContent" class="spotify-modal-content">
            <div class="spotify-loading">Loading...</div>
        </div>
    </div>
</div>

<!-- Spotify Playlist Modal -->
<div id="spotifyPlaylistModal" class="modal spotify-playlist-modal">
    <div class="modal-content modal-spotify-playlist">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/spotify" class="group-modal-icon-img spotify-icon" alt="">
                <h3 id="spotifyPlaylistTitle">Playlist</h3>
            </div>
            <button class="modal-close-btn" onclick="closeSpotifyPlaylistModal()">&times;</button>
        </div>
        <div id="spotifyPlaylistContent" class="spotify-playlist-content">
            <div class="spotify-loading">Loading tracks...</div>
        </div>
    </div>
</div>

<!-- Spotify Device Selector Modal -->
<div id="spotifyDeviceModal" class="modal spotify-device-modal">
    <div class="modal-content modal-spotify-device">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/volume-high" class="group-modal-icon-img" alt="">
                <h3>Select Device</h3>
            </div>
            <button class="modal-close-btn" onclick="closeSpotifyDeviceModal()">&times;</button>
        </div>
        <div id="spotifyDeviceContent" class="spotify-device-content">
            <div class="spotify-loading">Loading devices...</div>
        </div>
    </div>
</div>

<!-- Light Brightness Popup -->
<div id="lightBrightnessModal" class="modal light-brightness-modal">
    <div class="modal-content modal-light-brightness">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <img src="/icon/lightbulb" class="group-modal-icon-img" alt="">
                <h3 id="lightBrightnessTitle">Light</h3>
            </div>
            <button class="modal-close-btn" onclick="closeLightBrightnessPopup()">&times;</button>
        </div>
        <div class="light-brightness-content">
            <div class="light-brightness-toggle-row" onclick="toggleBrightnessPopupLight()">
                <span class="light-brightness-toggle-label">Power</span>
                <div class="toggle-switch" id="lightBrightnessToggle">
                    <div class="toggle-slider"></div>
                </div>
            </div>
            <div class="light-brightness-slider-container">
                <input type="range" id="lightBrightnessSlider" min="1" max="254" value="127"
                       oninput="updateLightBrightnessPreview(this.value)"
                       onchange="setLightBrightness(this.value)">
                <span id="lightBrightnessPercent" class="light-brightness-percent">50%</span>
            </div>
            <div class="light-brightness-actions">
                <button class="modal-btn secondary" onclick="closeLightBrightnessPopup()">Done</button>
            </div>
        </div>
    </div>
</div>

<!-- Scene Selection Popup -->
<div id="sceneModal" class="modal scene-modal">
    <div class="modal-content modal-scene">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <span class="group-modal-icon">ðŸŽ¬</span>
                <h3 id="sceneModalTitle">Scenes</h3>
            </div>
            <button class="modal-close-btn" onclick="closeSceneModal()">&times;</button>
        </div>
        <div class="scene-modal-content">
            <div id="sceneModalList" class="scene-modal-list">
                <!-- Scenes will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- Sync Mode Modal -->
<div id="syncModeModal" class="modal syncbox-modal">
    <div class="modal-content modal-syncbox">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <span class="group-modal-icon">ðŸŽ¬</span>
                <h3>Sync Mode</h3>
            </div>
            <button class="modal-close-btn" onclick="closeSyncModeModal()">&times;</button>
        </div>
        <div class="syncbox-modal-options">
            <!-- Options populated by JS -->
        </div>
    </div>
</div>

<!-- HDMI Input Modal -->
<div id="hdmiInputModal" class="modal syncbox-modal">
    <div class="modal-content modal-syncbox">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <span class="group-modal-icon">ðŸ“º</span>
                <h3>HDMI Input</h3>
            </div>
            <button class="modal-close-btn" onclick="closeHdmiInputModal()">&times;</button>
        </div>
        <div class="syncbox-modal-options">
            <!-- Options populated by JS -->
        </div>
    </div>
</div>

<script>
// Parse groups data
let groupsData = {};
try {
    const dataEl = document.getElementById('groupsData');
    if (dataEl) {
        const jsonStr = '[' + dataEl.textContent.trim() + ']';
        const groups = JSON.parse(jsonStr);
        groups.forEach(g => {
            groupsData[g.name] = g;
        });
    }
} catch (e) {
    console.error('Failed to parse groups data:', e);
}

// Parse cameras data
let camerasData = [];
try {
    const camerasEl = document.getElementById('camerasData');
    if (camerasEl) {
        camerasData = JSON.parse(camerasEl.textContent.trim());
    }
} catch (e) {
    console.error('Failed to parse cameras data:', e);
}

// Update group summaries on load
function updateGroupSummaries() {
    Object.keys(groupsData).forEach(groupName => {
        const group = groupsData[groupName];
        const summaryEl = document.getElementById('summary-' + groupName);
        if (!summaryEl) return;

        const onCount = group.cards.filter(c => c.isOn).length;
        const total = group.cards.length;

        if (groupName === 'Lights') {
            if (onCount === 0) {
                summaryEl.textContent = 'All off';
            } else if (onCount === total) {
                summaryEl.textContent = 'All on';
            } else {
                summaryEl.textContent = onCount + ' on';
            }
        } else if (groupName === 'Security') {
            const lockCard = group.cards.find(c => c.type === 'lock');
            const lockStatus = lockCard ? (lockCard.state === 'locked' ? 'Locked' : 'Unlocked') : '';
            const camCount = camerasData.length;
            if (lockStatus && camCount > 0) {
                summaryEl.textContent = `${lockStatus} Â· ${camCount} camera${camCount !== 1 ? 's' : ''}`;
            } else if (lockStatus) {
                summaryEl.textContent = lockStatus;
            } else if (camCount > 0) {
                summaryEl.textContent = `${camCount} camera${camCount !== 1 ? 's' : ''}`;
            }
        } else if (groupName === 'Climate') {
            // Find thermostat or show temp
            const climate = group.cards.find(c => c.type === 'climate');
            if (climate) {
                summaryEl.textContent = climate.state;
            } else {
                const temp = group.cards.find(c => c.unit === 'Â°F' || c.unit === 'Â°C');
                if (temp) {
                    summaryEl.textContent = temp.state + temp.unit;
                }
            }
        } else {
            summaryEl.textContent = total + ' device' + (total !== 1 ? 's' : '');
        }
    });
}

updateGroupSummaries();

// Group Modal
function openGroupModal(groupName) {
    const group = groupsData[groupName];
    if (!group) return;

    document.getElementById('groupModalIcon').textContent = group.icon;
    document.getElementById('groupModalTitle').textContent = group.name;

    const content = document.getElementById('groupModalContent');
    content.innerHTML = renderGroupContent(group);

    document.getElementById('groupModal').classList.add('active');
}

function closeGroupModal() {
    document.getElementById('groupModal').classList.remove('active');
}

// Cameras Modal
function openCamerasModal() {
    const content = document.getElementById('camerasModalContent');
    content.innerHTML = renderCamerasContent();
    document.getElementById('camerasModal').classList.add('active');
}

function closeCamerasModal() {
    document.getElementById('camerasModal').classList.remove('active');
}

function renderCamerasContent() {
    if (camerasData.length === 0) {
        return '<div class="no-cameras">No cameras configured</div>';
    }
    return camerasData.map(cam => `
        <div class="camera-row" onclick="openCameraView('${cam.name}', '${cam.label}')">
            <div class="camera-icon"><img src="/icon/video" class="camera-icon-img" alt=""></div>
            <div class="camera-info">
                <div class="camera-name">${cam.label}</div>
                <div class="camera-status">Tap to view</div>
            </div>
            <div class="camera-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"/>
                </svg>
            </div>
        </div>
    `).join('');
}

function openCameraView(cameraName, cameraLabel) {
    const modal = document.getElementById('cameraViewModal');
    const title = document.getElementById('cameraViewTitle');
    const stream = document.getElementById('cameraViewStream');

    title.textContent = cameraLabel;

    // Load the camera stream
    stream.src = `/api/camera/${cameraName}/stream`;
    stream.onerror = () => {
        stream.src = `/api/camera/${cameraName}/snapshot`;
    };

    modal.classList.add('active');
}

function closeCameraViewModal() {
    const modal = document.getElementById('cameraViewModal');
    const stream = document.getElementById('cameraViewStream');

    modal.classList.remove('active');
    stream.src = ''; // Stop the stream
}

function renderGroupContent(group) {
    // Security group gets special 2x2 grid layout with lock and cameras
    if (group.name === 'Security') {
        return renderSecurityGrid(group);
    }

    return group.cards.map(card => {
        // Climate entities get special rendering
        if (card.type === 'climate') {
            return renderClimateCard(card);
        }

        // Light groups get expandable rendering with member controls
        if (card.type === 'light' && card.isLightGroup && card.members && card.members.length > 0) {
            return renderLightGroupCard(card);
        }

        const isToggleable = ['light', 'switch', 'fan', 'lock'].includes(card.type);
        const toggleAttr = isToggleable ? `onclick="toggleEntity('${card.entityId}')"` : '';
        const cursorClass = isToggleable ? 'entity-toggleable' : '';
        const onClass = card.isOn ? 'entity-on' : '';

        return `
            <div class="entity-row ${cursorClass} ${onClass}" data-entity="${card.entityId}" ${toggleAttr}>
                <div class="entity-icon">${card.icon}</div>
                <div class="entity-info">
                    <div class="entity-name">${escapeHtml(card.name)}</div>
                    <div class="entity-state">${card.state}${card.unit ? ' ' + card.unit : ''}</div>
                </div>
                ${isToggleable ? `
                <div class="entity-toggle">
                    <div class="toggle-switch ${card.isOn ? 'on' : ''}">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                ` : ''}
            </div>
        `;
    }).join('');
}

function renderSecurityGrid(group) {
    // Find lock card
    const lockCard = group.cards.find(c => c.type === 'lock');

    let html = '<div class="security-grid">';

    // Lock card first
    if (lockCard) {
        const isLocked = lockCard.state === 'locked';
        html += `
            <div class="security-grid-item lock-item ${isLocked ? 'locked' : 'unlocked'}"
                 data-entity="${lockCard.entityId}"
                 onclick="toggleEntity('${lockCard.entityId}')">
                <div class="security-item-icon">${lockCard.icon}</div>
                <div class="security-item-name">${escapeHtml(lockCard.name)}</div>
                <div class="security-item-state">${lockCard.state}</div>
            </div>
        `;
    }

    // Camera cards
    camerasData.forEach(cam => {
        html += `
            <div class="security-grid-item camera-item"
                 onclick="openCameraView('${cam.name}', '${cam.label}')">
                <div class="security-item-icon"><img src="/icon/video" class="security-icon-img" alt=""></div>
                <div class="security-item-name">${escapeHtml(cam.label)}</div>
                <div class="security-item-state">Tap to view</div>
            </div>
        `;
    });

    html += '</div>';
    return html;
}

function renderLightGroupCard(card) {
    const onCount = card.members.filter(m => m.isOn).length;
    const totalCount = card.members.length;
    const groupState = onCount === 0 ? 'All off' : onCount === totalCount ? 'All on' : `${onCount} on`;

    return `
        <div class="light-group-card" data-entity="${card.entityId}">
            <div class="light-group-header entity-row entity-toggleable ${card.isOn ? 'entity-on' : ''}"
                 onclick="toggleEntity('${card.entityId}')">
                <div class="entity-icon">${card.icon}</div>
                <div class="entity-info">
                    <div class="entity-name">${escapeHtml(card.name)}</div>
                    <div class="entity-state">${groupState}</div>
                </div>
                <div class="entity-toggle">
                    <div class="toggle-switch ${card.isOn ? 'on' : ''}">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <button class="light-group-expand" onclick="event.stopPropagation(); toggleLightGroupExpand('${card.entityId}')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"/>
                    </svg>
                </button>
            </div>
            <div class="light-group-members" id="members-${card.entityId.replace('.', '-')}">
                ${card.members.map(member => `
                    <div class="entity-row entity-toggleable light-member ${member.isOn ? 'entity-on' : ''}"
                         data-entity="${member.entityId}"
                         onclick="toggleEntity('${member.entityId}')">
                        <div class="entity-icon">${member.icon}</div>
                        <div class="entity-info">
                            <div class="entity-name">${escapeHtml(member.name)}</div>
                            <div class="entity-state">${member.state}</div>
                        </div>
                        <div class="entity-toggle">
                            <div class="toggle-switch ${member.isOn ? 'on' : ''}">
                                <div class="toggle-slider"></div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

function toggleLightGroupExpand(entityId) {
    const membersId = 'members-' + entityId.replace('.', '-');
    const members = document.getElementById(membersId);
    const card = members.closest('.light-group-card');

    card.classList.toggle('expanded');
}

function renderClimateCard(card) {
    const attrs = card.attributes || {};
    const currentTemp = attrs.current_temperature || '--';
    const hvacModes = attrs.hvac_modes || ['off', 'heat', 'cool', 'auto'];
    const currentMode = card.state || 'off';
    const hvacAction = attrs.hvac_action || '';
    const minTemp = attrs.min_temp || 45;
    const maxTemp = attrs.max_temp || 95;
    const fanModes = attrs.fan_modes || [];
    const currentFanMode = attrs.fan_mode || '';

    // Handle dual setpoints for heat_cool/auto mode
    const isDualMode = currentMode === 'heat_cool' || currentMode === 'auto';
    const targetTempLow = attrs.target_temp_low || attrs.temperature || 70;
    const targetTempHigh = attrs.target_temp_high || attrs.temperature || 75;
    const targetTemp = attrs.temperature || 72;

    // Determine action display
    let actionText = currentMode === 'heat_cool' ? 'Auto' : currentMode;
    if (hvacAction && hvacAction !== 'idle' && hvacAction !== 'off') {
        actionText = hvacAction.charAt(0).toUpperCase() + hvacAction.slice(1);
    }

    // Build fan mode control HTML if fan modes are available
    let fanModeHtml = '';
    if (fanModes.length > 0) {
        fanModeHtml = `
            <div class="climate-fan-control">
                <span class="climate-fan-label">Fan:</span>
                <select class="climate-fan-select" onchange="setClimateFanMode('${card.entityId}', this.value)" onclick="event.stopPropagation()">
                    ${fanModes.map(mode => `
                        <option value="${mode}" ${mode === currentFanMode ? 'selected' : ''}>
                            ${mode.charAt(0).toUpperCase() + mode.slice(1)}
                        </option>
                    `).join('')}
                </select>
            </div>
        `;
    }

    return `
        <div class="entity-row climate-card" data-entity="${card.entityId}"
             data-min="${minTemp}" data-max="${maxTemp}"
             data-target-low="${targetTempLow}" data-target-high="${targetTempHigh}"
             data-target="${targetTemp}" data-dual="${isDualMode}">
            <div class="thermostat-main">
                <div class="thermostat-display">
                    <div class="thermostat-action ${hvacAction || currentMode}">${actionText}</div>
                    <div class="thermostat-current">
                        <span class="current-icon">ðŸŒ¡</span>
                        <span class="current-temp">${typeof currentTemp === 'number' ? Math.round(currentTemp) : currentTemp}Â°F</span>
                    </div>
                </div>

                ${isDualMode ? `
                <div class="thermostat-controls-right">
                    <div class="thermostat-setpoint-vertical heat">
                        <button class="thermostat-btn-sm plus" onclick="event.stopPropagation(); adjustClimateSetpoint('${card.entityId}', 'low', 1, ${minTemp}, ${maxTemp})">
                            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" fill="currentColor"/></svg>
                        </button>
                        <div class="setpoint-value">
                            <span class="setpoint-temp temp-low">${Math.round(targetTempLow)}Â°</span>
                            <span class="setpoint-label">Heat</span>
                        </div>
                        <button class="thermostat-btn-sm minus" onclick="event.stopPropagation(); adjustClimateSetpoint('${card.entityId}', 'low', -1, ${minTemp}, ${maxTemp})">
                            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z" fill="currentColor"/></svg>
                        </button>
                    </div>
                    <div class="thermostat-setpoint-vertical cool">
                        <button class="thermostat-btn-sm plus" onclick="event.stopPropagation(); adjustClimateSetpoint('${card.entityId}', 'high', 1, ${minTemp}, ${maxTemp})">
                            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" fill="currentColor"/></svg>
                        </button>
                        <div class="setpoint-value">
                            <span class="setpoint-temp temp-high">${Math.round(targetTempHigh)}Â°</span>
                            <span class="setpoint-label">Cool</span>
                        </div>
                        <button class="thermostat-btn-sm minus" onclick="event.stopPropagation(); adjustClimateSetpoint('${card.entityId}', 'high', -1, ${minTemp}, ${maxTemp})">
                            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z" fill="currentColor"/></svg>
                        </button>
                    </div>
                </div>
                ` : `
                <div class="thermostat-controls-right single">
                    <button class="thermostat-btn plus" onclick="event.stopPropagation(); adjustClimateTemp('${card.entityId}', 1, ${minTemp}, ${maxTemp})">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" fill="currentColor"/></svg>
                    </button>
                    <span class="temp-target">${Math.round(targetTemp)}<sup>Â°</sup></span>
                    <button class="thermostat-btn minus" onclick="event.stopPropagation(); adjustClimateTemp('${card.entityId}', -1, ${minTemp}, ${maxTemp})">
                        <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z" fill="currentColor"/></svg>
                    </button>
                </div>
                `}
            </div>

            <div class="thermostat-footer">
                <div class="climate-mode-row">
                    <select class="climate-mode-select" onchange="setClimateMode('${card.entityId}', this.value)" onclick="event.stopPropagation()">
                        ${hvacModes.map(mode => `
                            <option value="${mode}" ${mode === currentMode ? 'selected' : ''}>
                                ${mode === 'heat_cool' ? 'Auto' : mode.charAt(0).toUpperCase() + mode.slice(1)}
                            </option>
                        `).join('')}
                    </select>
                    ${fanModeHtml}
                </div>
            </div>
        </div>
    `;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function toggleEntity(entityID) {
    const entityRow = document.querySelector(`.entity-row[data-entity="${entityID}"]`);
    const groupCard = document.querySelector(`.group-card[data-group]`);

    if (entityRow) {
        entityRow.classList.add('entity-loading');
    }

    try {
        const resp = await fetch(`/api/toggle/${entityID}`, { method: 'POST' });
        if (resp.ok) {
            const data = await resp.json();

            // Update the entity row in modal
            if (entityRow) {
                entityRow.classList.toggle('entity-on', data.IsOn);
                entityRow.querySelector('.entity-state').textContent = data.State;
                const toggle = entityRow.querySelector('.toggle-switch');
                if (toggle) {
                    toggle.classList.toggle('on', data.IsOn);
                }
            }

            // Update the local data
            Object.keys(groupsData).forEach(groupName => {
                const card = groupsData[groupName].cards.find(c => c.entityId === entityID);
                if (card) {
                    card.isOn = data.IsOn;
                    card.state = data.State;
                }
            });

            // Update group summaries
            updateGroupSummaries();
        }
    } catch (err) {
        console.error('Toggle failed:', err);
    } finally {
        if (entityRow) {
            entityRow.classList.remove('entity-loading');
        }
    }
}

// Climate control functions - single temperature mode
async function adjustClimateTemp(entityID, delta, minTemp, maxTemp) {
    const climateCard = document.querySelector(`.climate-card[data-entity="${entityID}"]`);
    if (!climateCard) return;

    let targetTemp = parseFloat(climateCard.dataset.target);
    targetTemp = Math.max(minTemp, Math.min(maxTemp, targetTemp + delta));

    // Optimistically update UI
    const tempEl = climateCard.querySelector('.temp-target');
    if (tempEl) tempEl.innerHTML = Math.round(targetTemp) + '<sup>Â°</sup>';
    climateCard.dataset.target = targetTemp;

    try {
        const resp = await fetch(`/api/climate/${entityID}/temperature`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ temperature: targetTemp })
        });

        if (resp.ok) {
            const data = await resp.json();
            updateClimateCardData(entityID, data);
            // Re-render to update the arc
            reRenderClimateCard(entityID);
        }
    } catch (err) {
        console.error('Failed to set temperature:', err);
    }
}

// Climate control - adjust individual setpoint (heat low or cool high)
async function adjustClimateSetpoint(entityID, which, delta, minTemp, maxTemp) {
    const climateCard = document.querySelector(`.climate-card[data-entity="${entityID}"]`);
    if (!climateCard) return;

    let targetLow = parseFloat(climateCard.dataset.targetLow);
    let targetHigh = parseFloat(climateCard.dataset.targetHigh);

    if (which === 'low') {
        targetLow = Math.max(minTemp, Math.min(maxTemp, targetLow + delta));
        // Ensure low doesn't exceed high - 2
        if (targetLow > targetHigh - 2) {
            targetLow = targetHigh - 2;
        }
    } else {
        targetHigh = Math.max(minTemp, Math.min(maxTemp, targetHigh + delta));
        // Ensure high doesn't go below low + 2
        if (targetHigh < targetLow + 2) {
            targetHigh = targetLow + 2;
        }
    }

    // Optimistically update UI - update all temp displays
    climateCard.querySelectorAll('.temp-low').forEach(el => {
        el.innerHTML = Math.round(targetLow) + (el.querySelector('sup') ? '<sup>Â°</sup>' : 'Â°');
    });
    climateCard.querySelectorAll('.temp-high').forEach(el => {
        el.innerHTML = Math.round(targetHigh) + (el.querySelector('sup') ? '<sup>Â°</sup>' : 'Â°');
    });
    climateCard.dataset.targetLow = targetLow;
    climateCard.dataset.targetHigh = targetHigh;

    try {
        const resp = await fetch(`/api/climate/${entityID}/temperature`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target_temp_low: targetLow, target_temp_high: targetHigh })
        });

        if (resp.ok) {
            const data = await resp.json();
            updateClimateCardData(entityID, data);
            // Re-render to update the arc
            reRenderClimateCard(entityID);
        }
    } catch (err) {
        console.error('Failed to set temperature:', err);
    }
}

// Helper to re-render climate card after updates
function reRenderClimateCard(entityID) {
    const climateCard = document.querySelector(`.climate-card[data-entity="${entityID}"]`);
    if (!climateCard) return;

    const group = Object.values(groupsData).find(g =>
        g.cards.some(c => c.entityId === entityID)
    );
    if (group) {
        const card = group.cards.find(c => c.entityId === entityID);
        if (card) {
            climateCard.outerHTML = renderClimateCard(card);
        }
    }
}

async function setClimateMode(entityID, mode) {
    const climateCard = document.querySelector(`.climate-card[data-entity="${entityID}"]`);
    if (climateCard) {
        climateCard.classList.add('entity-loading');
    }

    try {
        const resp = await fetch(`/api/climate/${entityID}/mode`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: mode })
        });

        if (resp.ok) {
            const data = await resp.json();
            // Update local data and re-render
            updateClimateCardData(entityID, data);

            // Re-render the climate card
            const group = Object.values(groupsData).find(g =>
                g.cards.some(c => c.entityId === entityID)
            );
            if (group) {
                const card = group.cards.find(c => c.entityId === entityID);
                if (card && climateCard) {
                    climateCard.outerHTML = renderClimateCard(card);
                }
            }
        }
    } catch (err) {
        console.error('Failed to set HVAC mode:', err);
    } finally {
        if (climateCard) {
            climateCard.classList.remove('entity-loading');
        }
    }
}

async function setClimateFanMode(entityID, fanMode) {
    // Fan mode changes don't need a full re-render - just update local data
    try {
        const resp = await fetch(`/api/climate/${entityID}/fan`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fan_mode: fanMode })
        });

        if (resp.ok) {
            const data = await resp.json();
            // Just update local data, no re-render needed for fan mode
            updateClimateCardData(entityID, data);
        }
    } catch (err) {
        console.error('Failed to set fan mode:', err);
    }
}

function updateClimateCardData(entityID, data) {
    // Update local groupsData
    Object.keys(groupsData).forEach(groupName => {
        const card = groupsData[groupName].cards.find(c => c.entityId === entityID);
        if (card) {
            card.state = data.State || data.state;
            if (data.Attributes) {
                card.attributes = data.Attributes;
            } else if (data.attributes) {
                card.attributes = data.attributes;
            }
        }
    });
    updateGroupSummaries();
}

// Notifications Functions (placeholder)
function openNotifications() {
    // TODO: Implement notifications panel
    console.log('Notifications clicked - placeholder');
}

function updateNotificationBadge(count) {
    const badge = document.getElementById('notificationBadge');
    if (!badge) return;

    if (count > 0) {
        badge.style.display = 'flex';
        badge.textContent = count > 99 ? '99+' : count;
    } else {
        badge.style.display = 'none';
    }
}

// Refresh entity states every 30 seconds via AJAX (no page reload)
async function refreshEntityStates() {
    try {
        const resp = await fetch('/api/entities');
        if (!resp.ok) return;

        const groups = await resp.json();

        // Update groupsData with new states (normalize API response to match local format)
        groups.forEach(apiGroup => {
            // API returns capitalized Go struct names, local uses lowercase
            const groupName = apiGroup.Name || apiGroup.name;
            if (groupsData[groupName]) {
                // Normalize to lowercase property names
                groupsData[groupName] = {
                    name: groupName,
                    icon: apiGroup.Icon || apiGroup.icon,
                    cards: (apiGroup.Cards || apiGroup.cards || []).map(card => ({
                        entityId: card.EntityID || card.entityId,
                        name: card.Name || card.name,
                        state: card.State || card.state,
                        icon: card.Icon || card.icon,
                        type: card.Type || card.type,
                        unit: card.Unit || card.unit,
                        isOn: card.IsOn !== undefined ? card.IsOn : card.isOn,
                        isLightGroup: card.IsLightGroup !== undefined ? card.IsLightGroup : card.isLightGroup,
                        members: (card.Members || card.members || []).map(m => ({
                            entityId: m.EntityID || m.entityId,
                            name: m.Name || m.name,
                            state: m.State || m.state,
                            icon: m.Icon || m.icon,
                            type: m.Type || m.type,
                            isOn: m.IsOn !== undefined ? m.IsOn : m.isOn
                        })),
                        attributes: card.Attributes || card.attributes || {}
                    }))
                };
            }
        });

        // Update group card summaries
        updateGroupSummaries();

        // If a group modal is open, refresh its content
        const activeModal = document.querySelector('#groupModal.active');
        if (activeModal) {
            const titleEl = document.getElementById('groupModalTitle');
            if (titleEl) {
                const groupName = titleEl.textContent;
                const group = groupsData[groupName];
                if (group) {
                    document.getElementById('groupModalContent').innerHTML = renderGroupContent(group);
                }
            }
        }
    } catch (err) {
        console.error('Failed to refresh entity states:', err);
    }
}

setInterval(refreshEntityStates, 30000);

// ===== Hue Lights Integration =====
let hueRooms = [];

async function loadHueRooms() {
    try {
        const resp = await fetch('/api/hue/rooms');
        if (!resp.ok) {
            console.log('Hue not configured');
            updateHueSummary(null);
            return;
        }
        hueRooms = await resp.json();
        updateHueSummary(hueRooms);

        // Only re-render on entertainment tab (for streaming status updates)
        // Don't re-render room tabs - it resets scroll position
        const modal = document.getElementById('hueModal');
        if (modal && modal.classList.contains('active') && activeHueTab === 'entertainment') {
            renderHueContent();
        }
    } catch (err) {
        console.error('Failed to load Hue rooms:', err);
        updateHueSummary(null);
    }
}

function updateHueSummary(rooms) {
    const summaryEl = document.getElementById('summary-Hue');
    if (!summaryEl) return;

    if (!rooms || rooms.length === 0) {
        summaryEl.textContent = 'Not configured';
        return;
    }

    const onCount = rooms.filter(r => r.isOn).length;
    if (onCount === 0) {
        summaryEl.textContent = 'All off';
    } else if (onCount === rooms.length) {
        summaryEl.textContent = 'All on';
    } else {
        summaryEl.textContent = `${onCount} room${onCount !== 1 ? 's' : ''} on`;
    }
}

function openHueModal() {
    document.getElementById('hueModal').classList.add('active');
    renderHueContent();
}

function closeHueModal() {
    document.getElementById('hueModal').classList.remove('active');
}

let activeHueTab = null;
let selectedEntertainmentArea = null;
// Note: activatedEntertainmentArea is now tracked via streamingActive from API

// Check if a light is being synced (part of an actively streaming entertainment area)
function isLightSyncing(lightId) {
    if (!hueRooms) return false;
    const entertainment = hueRooms.filter(r => r.type === 'Entertainment' && r.streamingActive);
    for (const area of entertainment) {
        if (area.lights && area.lights.some(l => l.id === lightId)) {
            return true;
        }
    }
    return false;
}

function renderHueContent() {
    const content = document.getElementById('hueModalContent');

    if (!hueRooms || hueRooms.length === 0) {
        content.innerHTML = '<div class="hue-loading">No Hue rooms found. Check your Hue bridge configuration.</div>';
        return;
    }

    // Separate rooms/zones from entertainment areas
    const rooms = hueRooms.filter(r => r.type === 'Room' || r.type === 'Zone');
    const entertainment = hueRooms.filter(r => r.type === 'Entertainment');

    // Build tabs for rooms/zones only
    const tabs = rooms.map(r => ({
        id: r.id,
        name: r.name,
        icon: getRoomIcon(r.class || r.type),
        type: 'room'
    }));

    // Add single Entertainment Areas tab if there are entertainment areas
    if (entertainment.length > 0) {
        tabs.push({
            id: 'entertainment',
            name: 'Entertainment Areas',
            icon: 'ðŸŽ¬',
            type: 'entertainment'
        });
    }

    // Set default active tab
    if (!activeHueTab || !tabs.find(t => t.id === activeHueTab)) {
        activeHueTab = tabs[0]?.id || null;
    }

    // Set default selected entertainment area
    if (!selectedEntertainmentArea && entertainment.length > 0) {
        selectedEntertainmentArea = entertainment[0].id;
    }

    const tabsHtml = `
        <div class="hue-tabs">
            ${tabs.map(tab => `
                <button class="hue-tab ${activeHueTab === tab.id ? 'active' : ''} ${tab.type === 'entertainment' ? 'entertainment' : ''}"
                        onclick="switchHueTab('${tab.id}')">
                    <span class="hue-tab-icon">${tab.icon}</span>
                    <span class="hue-tab-name">${escapeHtml(tab.name)}</span>
                </button>
            `).join('')}
        </div>
    `;

    let contentHtml = '';
    if (activeHueTab === 'entertainment') {
        contentHtml = `
            <div class="hue-tab-content">
                ${renderEntertainmentContent(entertainment)}
            </div>
        `;
    } else {
        const activeRoom = rooms.find(r => r.id === activeHueTab);
        if (activeRoom) {
            contentHtml = `
                <div class="hue-tab-content">
                    ${renderHueRoomContent(activeRoom)}
                </div>
            `;
        }
    }

    content.innerHTML = tabsHtml + contentHtml;
}

function switchHueTab(tabId) {
    activeHueTab = tabId;
    renderHueContent();
}

function selectEntertainmentArea(areaId) {
    selectedEntertainmentArea = areaId;
    renderHueContent();
}

// Sync Box data
let syncBoxes = [];
let syncBoxStatuses = {};
let selectedSyncBox = 0;

async function loadSyncBoxes() {
    try {
        const resp = await fetch('/api/syncbox');
        if (resp.ok) {
            syncBoxes = await resp.json();
            // Load status for each sync box
            for (const box of syncBoxes) {
                loadSyncBoxStatus(box.index);
            }
        }
    } catch (err) {
        console.log('Sync boxes not available:', err);
    }
}

async function loadSyncBoxStatus(index) {
    try {
        const resp = await fetch(`/api/syncbox/${index}/status`);
        if (resp.ok) {
            syncBoxStatuses[index] = await resp.json();
            // Re-render if modal is open
            const modal = document.getElementById('hueModal');
            if (modal && modal.classList.contains('active') && activeHueTab === 'entertainment') {
                renderHueContent();
            }
        }
    } catch (err) {
        console.log(`Failed to load sync box ${index} status:`, err);
    }
}

async function toggleSyncBox(index, active) {
    try {
        const resp = await fetch(`/api/syncbox/${index}/sync`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ active })
        });
        if (resp.ok) {
            await loadSyncBoxStatus(index);
        }
    } catch (err) {
        console.error('Failed to toggle sync:', err);
    }
}

async function setSyncBoxArea(index, groupId) {
    try {
        const resp = await fetch(`/api/syncbox/${index}/area`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ groupId })
        });
        if (resp.ok) {
            await loadSyncBoxStatus(index);
            await loadHueRooms(); // Refresh to get updated streaming status
        }
    } catch (err) {
        console.error('Failed to set entertainment area:', err);
    }
}

async function setSyncBoxMode(index, mode) {
    try {
        const resp = await fetch(`/api/syncbox/${index}/mode`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode })
        });
        if (resp.ok) {
            await loadSyncBoxStatus(index);
        }
    } catch (err) {
        console.error('Failed to set mode:', err);
    }
}

async function setSyncBoxInput(index, hdmiSource) {
    try {
        const resp = await fetch(`/api/syncbox/${index}/input`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ hdmiSource })
        });
        if (resp.ok) {
            await loadSyncBoxStatus(index);
        }
    } catch (err) {
        console.error('Failed to set HDMI input:', err);
    }
}

function selectSyncBox(index) {
    selectedSyncBox = index;
    renderHueContent();
}

function renderEntertainmentContent(areas) {
    // Use streamingActive from the API
    const activeArea = areas.find(a => a.streamingActive);

    // If we have Sync Boxes configured, show Sync Box control UI
    if (syncBoxes.length > 0) {
        return renderSyncBoxContent(areas, activeArea);
    }

    // Otherwise show read-only entertainment areas status
    return `
        <div class="hue-entertainment-content">
            ${activeArea ? `
            <div class="hue-entertainment-active-banner">
                <span class="active-indicator"></span>
                <span>Currently Streaming: <strong>${escapeHtml(activeArea.name)}</strong></span>
            </div>
            ` : '<div class="hue-entertainment-notice">No Sync Boxes configured. Add SYNC_BOXES to .env to control streaming.</div>'}

            <div class="hue-entertainment-selector">
                <label>Entertainment Areas</label>
                <div class="hue-entertainment-areas">
                    ${areas.map(area => `
                        <div class="hue-entertainment-area-btn ${area.streamingActive ? 'activated' : ''}">
                            <span class="area-icon">ðŸŽ¬</span>
                            <span class="area-name">${escapeHtml(area.name)}</span>
                            <span class="area-lights">${area.lights?.length || 0} lights</span>
                            ${area.streamingActive ? '<span class="area-active-badge">STREAMING</span>' : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
}

function renderSyncBoxContent(areas, activeArea) {
    const box = syncBoxes[selectedSyncBox];
    const status = syncBoxStatuses[selectedSyncBox] || {};
    const exec = status.execution || {};
    const hue = status.hue || {};
    const groups = hue.groups || {};
    const currentGroupId = exec.hueTarget || '';
    const isSyncing = exec.syncActive;
    const currentMode = exec.mode || 'video';
    const currentInput = exec.hdmiSource || 'input1';
    const hdmi = status.hdmi || {};

    // Helper to get HDMI input name
    const getHdmiName = (inputKey, defaultNum) => {
        const input = hdmi[inputKey];
        return input?.name || `HDMI ${defaultNum}`;
    };

    // Get syncing status for all boxes
    const boxStatuses = syncBoxes.map((sb, i) => {
        const s = syncBoxStatuses[i] || {};
        return s.execution?.syncActive || false;
    });

    return `
        <div class="hue-entertainment-content">
            <div class="hue-syncbox-panel">
                <div class="hue-syncbox-header">
                    <div class="hue-syncbox-selector">
                        ${syncBoxes.map((sb, i) => {
                            const boxSyncing = boxStatuses[i];
                            return `
                            <label class="hue-syncbox-radio ${i === selectedSyncBox ? 'selected' : ''} ${boxSyncing ? 'syncing' : ''}"
                                   onclick="selectSyncBox(${i})">
                                <input type="radio" name="syncbox" ${i === selectedSyncBox ? 'checked' : ''}>
                                <span class="radio-name">${escapeHtml(sb.name)}</span>
                                ${boxSyncing ? '<span class="radio-status">Syncing</span>' : ''}
                            </label>
                        `}).join('')}
                    </div>
                    <button class="hue-syncbox-toggle-btn ${isSyncing ? 'streaming' : ''}"
                            onclick="toggleSyncBox(${selectedSyncBox}, ${!isSyncing})">
                        ${isSyncing ? `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="6" y="4" width="4" height="16"/>
                            <rect x="14" y="4" width="4" height="16"/>
                        </svg>
                        Stop Sync
                        ` : `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        Start Sync
                        `}
                    </button>
                </div>

                <div class="hue-syncbox-split-layout">
                    <div class="hue-syncbox-left-column">
                        <div class="hue-syncbox-grid-section">
                            <label>Entertainment Area</label>
                            <div class="hue-syncbox-grid-4col">
                                ${Object.entries(groups).map(([id, group]) => `
                                    <button class="hue-syncbox-tile ${id === currentGroupId ? 'selected' : ''}"
                                            onclick="setSyncBoxArea(${selectedSyncBox}, '${id}')">
                                        <span class="tile-icon">ðŸŽ¬</span>
                                        <span class="tile-name">${escapeHtml(group.name)}</span>
                                        <span class="tile-info">${group.numLights} lights</span>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="hue-syncbox-right-column">
                        <div class="hue-syncbox-grid-section">
                            <label>HDMI Input</label>
                            <div class="hue-syncbox-grid-4col">
                                ${['input1', 'input2', 'input3', 'input4'].map((input, i) => `
                                    <button class="hue-syncbox-tile ${input === currentInput ? 'selected' : ''}"
                                            onclick="setSyncBoxInput(${selectedSyncBox}, '${input}')">
                                        <span class="tile-icon">ðŸ“º</span>
                                        <span class="tile-name">${escapeHtml(getHdmiName(input, i + 1))}</span>
                                        <span class="tile-info">HDMI ${i + 1}</span>
                                    </button>
                                `).join('')}
                            </div>
                        </div>

                        <div class="hue-syncbox-grid-section">
                            <label>Sync Mode</label>
                            <div class="hue-syncbox-grid-4col">
                                ${['video', 'music', 'game'].map(mode => `
                                    <button class="hue-syncbox-tile ${mode === currentMode ? 'selected' : ''}"
                                            onclick="setSyncBoxMode(${selectedSyncBox}, '${mode}')">
                                        <span class="tile-icon">${mode === 'video' ? 'ðŸŽ¬' : mode === 'music' ? 'ðŸŽµ' : 'ðŸŽ®'}</span>
                                        <span class="tile-name">${mode.charAt(0).toUpperCase() + mode.slice(1)}</span>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function openSyncModeModal() {
    const status = syncBoxStatuses[selectedSyncBox] || {};
    const exec = status.execution || {};
    const currentMode = exec.mode || 'video';

    const modal = document.getElementById('syncModeModal');
    const content = modal.querySelector('.syncbox-modal-options');
    content.innerHTML = ['video', 'music', 'game'].map(mode => `
        <button class="syncbox-modal-option ${mode === currentMode ? 'active' : ''}"
                onclick="setSyncBoxMode(${selectedSyncBox}, '${mode}'); closeSyncModeModal();">
            <span class="option-icon">${mode === 'video' ? 'ðŸŽ¬' : mode === 'music' ? 'ðŸŽµ' : 'ðŸŽ®'}</span>
            <span class="option-label">${mode.charAt(0).toUpperCase() + mode.slice(1)}</span>
        </button>
    `).join('');
    modal.classList.add('active');
}

function closeSyncModeModal() {
    document.getElementById('syncModeModal').classList.remove('active');
}

function openHdmiInputModal() {
    const status = syncBoxStatuses[selectedSyncBox] || {};
    const exec = status.execution || {};
    const hdmi = status.hdmi || {};
    const currentInput = exec.hdmiSource || 'input1';

    const getHdmiName = (inputKey, defaultNum) => {
        const input = hdmi[inputKey];
        return input?.name || `HDMI ${defaultNum}`;
    };

    const modal = document.getElementById('hdmiInputModal');
    const content = modal.querySelector('.syncbox-modal-options');
    content.innerHTML = ['input1', 'input2', 'input3', 'input4'].map((input, i) => `
        <button class="syncbox-modal-option ${input === currentInput ? 'active' : ''}"
                onclick="setSyncBoxInput(${selectedSyncBox}, '${input}'); closeHdmiInputModal();">
            <span class="option-label">${escapeHtml(getHdmiName(input, i + 1))}</span>
        </button>
    `).join('');
    modal.classList.add('active');
}

function closeHdmiInputModal() {
    document.getElementById('hdmiInputModal').classList.remove('active');
}

async function stopSyncFromBanner() {
    // Stop sync on all configured sync boxes
    for (let i = 0; i < syncBoxes.length; i++) {
        try {
            await fetch(`/api/syncbox/${i}/sync`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ active: false })
            });
        } catch (err) {
            console.error(`Failed to stop sync on box ${i}:`, err);
        }
    }
    // Reload data
    await loadHueRooms();
    for (const box of syncBoxes) {
        loadSyncBoxStatus(box.index);
    }
    renderHueContent();
}

// Load sync boxes on startup
loadSyncBoxes();

function renderHueRoomContent(room) {
    const lightsOnCount = room.lights ? room.lights.filter(l => l.state && l.state.on).length : 0;
    const totalLights = room.lights ? room.lights.length : 0;
    const toggleText = room.isOn ? `Turn off ${escapeHtml(room.name)}` : `Turn on ${escapeHtml(room.name)}`;
    const hasSyncingLights = room.lights && room.lights.some(l => isLightSyncing(l.id));
    const allLightsSyncing = room.lights && room.lights.length > 0 && room.lights.every(l => isLightSyncing(l.id));

    return `
        <div class="hue-room-content" data-room-id="${room.id}">
            ${hasSyncingLights ? `
            <div class="hue-sync-warning-banner">
                <div class="sync-warning-text">
                    <div class="sync-warning-title">Hue Sync is active</div>
                    <div class="sync-warning-subtitle">Stop syncing to control the lights</div>
                </div>
                <button class="sync-warning-stop-btn" onclick="stopSyncFromBanner()">Stop Sync</button>
            </div>
            ` : ''}
            <div class="hue-room-layout">
                <div class="hue-room-left-column">
                    <div class="hue-room-main-toggle" onclick="toggleHueRoom('${room.id}')">
                        <div class="hue-room-power ${room.isOn ? 'on' : ''}">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                                <line x1="12" y1="2" x2="12" y2="12"/>
                            </svg>
                        </div>
                        <div class="hue-room-power-label">${toggleText}</div>
                    </div>

                    <div class="hue-room-brightness-section ${allLightsSyncing ? 'disabled' : ''}">
                        <label>Brightness</label>
                        <div class="hue-brightness-control">
                            <input type="range" min="1" max="254" value="${getAverageRoomBrightness(room)}"
                                   ${allLightsSyncing ? 'disabled' : ''}
                                   oninput="this.nextElementSibling.textContent = Math.round(this.value / 254 * 100) + '%'"
                                   onchange="setHueRoomBrightness('${room.id}', this.value)">
                            <span class="hue-brightness-value">${Math.round(getAverageRoomBrightness(room) / 254 * 100)}%</span>
                        </div>
                    </div>
                </div>

                <div class="hue-room-right-column">
                    ${room.scenes && room.scenes.length > 0 ? `
                    <div class="hue-room-scenes-section">
                        <button class="hue-scenes-open-btn" onclick="openSceneModal('${room.id}', '${escapeHtml(room.name)}')">
                            <span class="scenes-btn-icon">ðŸŽ¬</span>
                            <span class="scenes-btn-text">Scenes</span>
                            <span class="scenes-btn-count">${room.scenes.length}</span>
                        </button>
                    </div>
                    ` : ''}

                    <div class="hue-room-lights-section">
                        <label>Lights</label>
                        <div class="hue-lights-grid">
                        ${room.lights && room.lights.length > 0 ? room.lights.map(light => {
                            const syncing = isLightSyncing(light.id);
                            return `
                            <div class="hue-light-row ${light.state && light.state.on ? 'light-on' : ''} ${syncing ? 'syncing' : ''}"
                                 data-light-id="${light.id}"
                                 ${syncing ? '' : `onclick="openLightBrightnessPopup('${light.id}', '${escapeHtml(light.name)}', ${light.state?.bri || 127}, ${light.state?.on || false})"`}>
                                <div class="hue-light-icon">${syncing ? 'ðŸŽ¬' : 'ðŸ’¡'}</div>
                                <div class="hue-light-info">
                                    <div class="hue-light-name">${escapeHtml(light.name)}</div>
                                    <div class="hue-light-state ${syncing ? 'sync-active' : ''}">${syncing ? 'Sync Active' : (light.state && light.state.on ? Math.round(light.state.bri / 254 * 100) + '%' : 'Off')}</div>
                                </div>
                                ${syncing ? '' : `
                                <div class="hue-light-toggle" onclick="event.stopPropagation(); toggleHueLight('${light.id}')">
                                    <div class="toggle-switch ${light.state && light.state.on ? 'on' : ''}">
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>
                                `}
                            </div>
                        `}).join('') : '<div class="no-lights">No lights in this room</div>'}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function renderHueRoom(room) {
    const lightsOnCount = room.lights ? room.lights.filter(l => l.state && l.state.on).length : 0;
    const totalLights = room.lights ? room.lights.length : 0;
    const statusText = lightsOnCount === 0 ? 'Off' : lightsOnCount === totalLights ? 'All on' : `${lightsOnCount} on`;
    const isEntertainment = room.type === 'Entertainment';

    return `
        <div class="hue-room-card ${room.isOn ? 'room-on' : ''} ${isEntertainment ? 'entertainment-area' : ''}" data-room-id="${room.id}">
            <div class="hue-room-header" onclick="${isEntertainment ? `activateEntertainment('${room.id}')` : `toggleHueRoom('${room.id}')`}">
                <div class="hue-room-icon">${getRoomIcon(room.class || room.type)}</div>
                <div class="hue-room-info">
                    <div class="hue-room-name">${escapeHtml(room.name)}</div>
                    <div class="hue-room-status">${isEntertainment ? 'Tap to activate' : statusText}</div>
                </div>
                ${!isEntertainment ? `
                <div class="hue-room-toggle">
                    <div class="toggle-switch ${room.isOn ? 'on' : ''}">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <button class="hue-room-expand" onclick="event.stopPropagation(); toggleHueRoomExpand('${room.id}')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"/>
                    </svg>
                </button>
                ` : `
                <div class="entertainment-activate-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </div>
                `}
            </div>
            ${!isEntertainment ? `
            <div class="hue-room-details" id="hue-room-details-${room.id}">
                <div class="hue-room-brightness">
                    <label>Brightness</label>
                    <input type="range" min="1" max="254" value="${getAverageRoomBrightness(room)}"
                           onchange="setHueRoomBrightness('${room.id}', this.value)"
                           onclick="event.stopPropagation()">
                </div>
                ${room.scenes && room.scenes.length > 0 ? `
                <div class="hue-room-scenes">
                    <label>Scenes</label>
                    <div class="hue-scenes-grid">
                        ${room.scenes.slice(0, 8).map(scene => `
                            <button class="hue-scene-btn" onclick="event.stopPropagation(); activateHueScene('${scene.id}')">
                                ${escapeHtml(scene.name)}
                            </button>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                <div class="hue-room-lights">
                    <label>Individual Lights</label>
                    ${room.lights && room.lights.length > 0 ? room.lights.map(light => `
                        <div class="hue-light-row ${light.state && light.state.on ? 'light-on' : ''}"
                             data-light-id="${light.id}"
                             onclick="event.stopPropagation(); toggleHueLight('${light.id}')">
                            <div class="hue-light-icon">ðŸ’¡</div>
                            <div class="hue-light-info">
                                <div class="hue-light-name">${escapeHtml(light.name)}</div>
                                <div class="hue-light-state">${light.state && light.state.on ? 'On' : 'Off'}</div>
                            </div>
                            <div class="hue-light-toggle">
                                <div class="toggle-switch ${light.state && light.state.on ? 'on' : ''}">
                                    <div class="toggle-slider"></div>
                                </div>
                            </div>
                        </div>
                    `).join('') : '<div class="no-lights">No lights in this room</div>'}
                </div>
            </div>
            ` : ''}
        </div>
    `;
}

function getRoomIcon(roomClass) {
    const icons = {
        'Living room': 'ðŸ›‹ï¸',
        'Bedroom': 'ðŸ›ï¸',
        'Office': 'ðŸ’»',
        'Kitchen': 'ðŸ³',
        'Bathroom': 'ðŸš¿',
        'Hallway': 'ðŸšª',
        'Garage': 'ðŸš—',
        'Balcony': 'ðŸŒ…',
        'Other': 'ðŸ’¡',
        'Room': 'ðŸ ',
        'Zone': 'ðŸ“',
        'TV': 'ðŸ“º',
        'Entertainment': 'ðŸŽ¬'
    };
    return icons[roomClass] || 'ðŸ’¡';
}

function getAverageRoomBrightness(room) {
    if (!room.lights || room.lights.length === 0) return 127;
    const onLights = room.lights.filter(l => l.state && l.state.on);
    if (onLights.length === 0) return 127;
    const sum = onLights.reduce((acc, l) => acc + (l.state.bri || 127), 0);
    return Math.round(sum / onLights.length);
}

function toggleHueRoomExpand(roomId) {
    const roomCard = document.querySelector(`.hue-room-card[data-room-id="${roomId}"]`);
    if (roomCard) {
        roomCard.classList.toggle('expanded');
    }
}

async function toggleHueRoom(roomId) {
    const roomCard = document.querySelector(`.hue-room-card[data-room-id="${roomId}"]`);
    if (roomCard) roomCard.classList.add('loading');

    try {
        const resp = await fetch(`/api/hue/group/${roomId}/toggle`, { method: 'POST' });
        if (resp.ok) {
            hueRooms = await resp.json();
            updateHueSummary(hueRooms);
            renderHueContent();
        }
    } catch (err) {
        console.error('Failed to toggle room:', err);
    } finally {
        if (roomCard) roomCard.classList.remove('loading');
    }
}

async function setHueRoomBrightness(roomId, brightness) {
    try {
        const resp = await fetch(`/api/hue/group/${roomId}/brightness`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ brightness: parseInt(brightness) })
        });
        if (resp.ok) {
            hueRooms = await resp.json();
            updateHueSummary(hueRooms);
            // Don't re-render to avoid slider jumping
        }
    } catch (err) {
        console.error('Failed to set brightness:', err);
    }
}

async function toggleHueLight(lightId) {
    const lightRow = document.querySelector(`.hue-light-row[data-light-id="${lightId}"]`);
    if (lightRow) lightRow.classList.add('loading');

    try {
        const resp = await fetch(`/api/hue/light/${lightId}/toggle`, { method: 'POST' });
        if (resp.ok) {
            // Reload full room data to get updated state
            await loadHueRooms();
            renderHueContent();
        }
    } catch (err) {
        console.error('Failed to toggle light:', err);
    } finally {
        if (lightRow) lightRow.classList.remove('loading');
    }
}

// Light brightness popup
let currentBrightnessLightId = null;
let currentBrightnessLightIsOn = false;

function openLightBrightnessPopup(lightId, lightName, currentBri, isOn) {
    currentBrightnessLightId = lightId;
    currentBrightnessLightIsOn = isOn;
    document.getElementById('lightBrightnessTitle').textContent = lightName;
    const slider = document.getElementById('lightBrightnessSlider');
    slider.value = currentBri || 127;
    updateLightBrightnessPreview(slider.value);
    // Update toggle state
    const toggle = document.getElementById('lightBrightnessToggle');
    if (isOn) {
        toggle.classList.add('on');
    } else {
        toggle.classList.remove('on');
    }
    document.getElementById('lightBrightnessModal').classList.add('active');
}

function closeLightBrightnessPopup() {
    document.getElementById('lightBrightnessModal').classList.remove('active');
    currentBrightnessLightId = null;
    currentBrightnessLightIsOn = false;
}

async function toggleBrightnessPopupLight() {
    if (!currentBrightnessLightId) return;

    try {
        const resp = await fetch(`/api/hue/light/${currentBrightnessLightId}/toggle`, { method: 'POST' });
        if (resp.ok) {
            currentBrightnessLightIsOn = !currentBrightnessLightIsOn;
            const toggle = document.getElementById('lightBrightnessToggle');
            if (currentBrightnessLightIsOn) {
                toggle.classList.add('on');
            } else {
                toggle.classList.remove('on');
            }
            await loadHueRooms();
            renderHueContent();
        }
    } catch (err) {
        console.error('Failed to toggle light:', err);
    }
}

function updateLightBrightnessPreview(value) {
    const percent = Math.round(value / 254 * 100);
    document.getElementById('lightBrightnessPercent').textContent = percent + '%';
}

async function setLightBrightness(value) {
    if (!currentBrightnessLightId) return;

    try {
        const resp = await fetch(`/api/hue/light/${currentBrightnessLightId}/brightness`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ brightness: parseInt(value) })
        });
        if (resp.ok) {
            await loadHueRooms();
            renderHueContent();
        }
    } catch (err) {
        console.error('Failed to set brightness:', err);
    }
}

async function activateHueScene(sceneId) {
    try {
        const resp = await fetch(`/api/hue/scene/${sceneId}/activate`, { method: 'POST' });
        if (resp.ok) {
            hueRooms = await resp.json();
            updateHueSummary(hueRooms);
            renderHueContent();
            closeSceneModal();
        }
    } catch (err) {
        console.error('Failed to activate scene:', err);
    }
}

// Scene modal
let currentSceneRoomId = null;

function openSceneModal(roomId, roomName) {
    currentSceneRoomId = roomId;
    document.getElementById('sceneModalTitle').textContent = `${roomName} Scenes`;

    // Find the room and render its scenes
    const room = hueRooms.find(r => r.id === roomId);
    if (room && room.scenes) {
        const scenesList = document.getElementById('sceneModalList');
        scenesList.innerHTML = room.scenes.map(scene => `
            <button class="scene-modal-btn" onclick="activateHueScene('${scene.id}')">
                ${escapeHtml(scene.name)}
            </button>
        `).join('');
    }

    document.getElementById('sceneModal').classList.add('active');
}

function closeSceneModal() {
    document.getElementById('sceneModal').classList.remove('active');
    currentSceneRoomId = null;
}

// Periodically refresh sync box status when entertainment tab is active
setInterval(() => {
    const modal = document.getElementById('hueModal');
    if (modal && modal.classList.contains('active') && activeHueTab === 'entertainment') {
        for (const box of syncBoxes) {
            loadSyncBoxStatus(box.index);
        }
    }
}, 3000); // Every 3 seconds

// Load Hue rooms on page load
loadHueRooms();

// Refresh Hue state every second for real-time responsiveness
setInterval(loadHueRooms, 1000);

// ===== Spotify Integration =====
let spotifyStatus = null;
let spotifyPlayback = null;
let spotifyDevices = [];
let spotifyPlaylists = [];
let activeSpotifyTab = 'now-playing';

async function checkSpotifyStatus() {
    try {
        const resp = await fetch('/api/spotify/status');
        if (resp.ok) {
            spotifyStatus = await resp.json();
            const card = document.getElementById('spotifyCard');
            if (spotifyStatus.configured) {
                card.style.display = '';
                if (spotifyStatus.authenticated) {
                    loadSpotifyPlayback();
                } else {
                    document.getElementById('summary-Spotify').textContent = 'Not connected';
                }
            }
        }
    } catch (err) {
        console.log('Spotify not available:', err);
    }
}

async function loadSpotifyPlayback() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/playback');
        if (resp.ok) {
            const newPlayback = await resp.json();

            // Preserve local progress if same track is playing to prevent jumping
            const sameTrack = spotifyPlayback?.item?.id === newPlayback?.item?.id;
            const wasPlaying = spotifyPlayback?.is_playing;
            const nowPlaying = newPlayback?.is_playing;

            if (sameTrack && wasPlaying && nowPlaying && spotifyPlayback.progress_ms) {
                // Keep local progress, only sync if drift is significant (> 3 seconds)
                const drift = Math.abs(newPlayback.progress_ms - spotifyPlayback.progress_ms);
                if (drift > 3000) {
                    // Significant drift - sync with server
                    spotifyPlayback = newPlayback;
                } else {
                    // Keep local progress, update other fields
                    const localProgress = spotifyPlayback.progress_ms;
                    spotifyPlayback = newPlayback;
                    spotifyPlayback.progress_ms = localProgress;
                }
            } else {
                // Track changed or play state changed - use server data
                spotifyPlayback = newPlayback;
            }

            updateSpotifySummary();

            // Update only the now playing panel if modal is open (don't re-render entire content)
            const modal = document.getElementById('spotifyModal');
            if (modal && modal.classList.contains('active')) {
                updateNowPlayingPanel();
            }
        } else if (resp.status === 401) {
            document.getElementById('summary-Spotify').textContent = 'Not connected';
        }
    } catch (err) {
        console.error('Failed to load Spotify playback:', err);
    }
}

function updateNowPlayingPanel() {
    // Skip full re-render while user is adjusting volume to prevent slider jumping
    if (isAdjustingVolume) {
        updateProgressBar();
        updateTracksNowPlaying();
        return;
    }

    const leftPanel = document.querySelector('.spotify-left-panel');
    if (leftPanel) {
        leftPanel.innerHTML = renderNowPlayingPanel();
        updateProgressBar();
    }
    // Also update now-playing indicator on tracks
    updateTracksNowPlaying();
}

function updateTracksNowPlaying() {
    const currentTrackUri = spotifyPlayback?.item?.uri;
    const isPlaying = spotifyPlayback?.is_playing;

    // Update artist tracks
    document.querySelectorAll('.spotify-artist-track[data-track-uri]').forEach((track, index) => {
        const trackUri = track.dataset.trackUri;
        const isCurrentTrack = trackUri === currentTrackUri;
        const numEl = track.querySelector('.spotify-artist-track-num');

        track.classList.toggle('now-playing', isCurrentTrack);
        if (numEl) {
            if (isCurrentTrack && isPlaying) {
                numEl.innerHTML = '<img src="/icon/playing" class="now-playing-icon" alt="Playing">';
            } else {
                numEl.textContent = index + 1;
            }
        }
    });

    // Update album tracks
    document.querySelectorAll('.spotify-album-track[data-track-uri]').forEach((track, index) => {
        const trackUri = track.dataset.trackUri;
        const isCurrentTrack = trackUri === currentTrackUri;
        const numEl = track.querySelector('.spotify-album-track-num');

        track.classList.toggle('now-playing', isCurrentTrack);
        if (numEl) {
            if (isCurrentTrack && isPlaying) {
                numEl.innerHTML = '<img src="/icon/playing" class="now-playing-icon" alt="Playing">';
            } else {
                numEl.textContent = index + 1;
            }
        }
    });
}

async function loadSpotifyDevices() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/devices');
        if (resp.ok) {
            spotifyDevices = await resp.json();
        }
    } catch (err) {
        console.error('Failed to load Spotify devices:', err);
    }
}

async function loadSpotifyPlaylists() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/playlists?limit=50');
        if (resp.ok) {
            const data = await resp.json();
            spotifyPlaylists = data.items || [];
        }
    } catch (err) {
        console.error('Failed to load Spotify playlists:', err);
    }
}

async function loadRecentTracks() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/recent?limit=50');
        if (resp.ok) {
            const data = await resp.json();
            spotifyRecentItems = data.items || [];
            // Re-render browse content if modal is open and on home tab
            const browseContent = document.getElementById('spotifyBrowseContent');
            if (browseContent && activeSpotifyBrowseTab === 'home') {
                browseContent.innerHTML = renderBrowseContent();
            }
        }
    } catch (err) {
        console.error('Failed to load recent tracks:', err);
    }
}

async function loadTopArtists() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/top/artists?limit=20');
        if (resp.ok) {
            const data = await resp.json();
            spotifyTopArtists = data.items || [];
        }
    } catch (err) {
        console.error('Failed to load top artists:', err);
    }
}

async function loadTopTracks() {
    if (!spotifyStatus || !spotifyStatus.authenticated) return;

    try {
        const resp = await fetch('/api/spotify/top/tracks?limit=20');
        if (resp.ok) {
            const data = await resp.json();
            spotifyTopTracks = data.items || [];
        }
    } catch (err) {
        console.error('Failed to load top tracks:', err);
    }
}

function updateSpotifySummary() {
    const summaryEl = document.getElementById('summary-Spotify');
    if (summaryEl) {
        if (!spotifyPlayback || !spotifyPlayback.item) {
            summaryEl.textContent = 'Not playing';
        } else {
            const track = spotifyPlayback.item;
            const artist = track.artists ? track.artists.map(a => a.name).join(', ') : '';
            summaryEl.textContent = spotifyPlayback.is_playing
                ? `${track.name} - ${artist}`
                : 'Paused';
        }
    }

    // Update mini player
    updateMiniPlayer();
}

function updateMiniPlayer() {
    const miniPlayer = document.getElementById('spotifyMiniPlayer');
    if (!miniPlayer) return;

    // Show mini player only when there's active playback
    if (!spotifyPlayback || !spotifyPlayback.item) {
        miniPlayer.style.display = 'none';
        updateScreensaverSpotify();
        return;
    }

    miniPlayer.style.display = 'flex';

    const track = spotifyPlayback.item;
    const album = track.album || {};
    const artists = track.artists ? track.artists.map(a => a.name).join(', ') : '';
    const albumArt = album.images && album.images.length > 0
        ? album.images[album.images.length - 1].url
        : '';

    // Update album art
    const artEl = document.getElementById('spotifyMiniArt');
    if (artEl) {
        artEl.innerHTML = albumArt ? `<img src="${albumArt}" alt="">` : '';
    }

    // Update track info
    const infoEl = document.getElementById('spotifyMiniInfo');
    if (infoEl) {
        infoEl.innerHTML = `
            <div class="spotify-mini-track">${escapeHtml(track.name)}</div>
            <div class="spotify-mini-artist">${escapeHtml(artists)}</div>
        `;
    }

    // Update play/pause icon
    const playIcon = document.getElementById('spotifyMiniPlayIcon');
    if (playIcon) {
        playIcon.src = spotifyPlayback.is_playing ? '/icon/pause' : '/icon/play';
        playIcon.alt = spotifyPlayback.is_playing ? 'Pause' : 'Play';
    }

    // Update volume slider and icon (only if not currently adjusting)
    if (!isAdjustingVolume) {
        const volumeSlider = document.getElementById('spotifyMiniVolumeSlider');
        if (volumeSlider && spotifyPlayback.device) {
            volumeSlider.value = spotifyPlayback.device.volume_percent || 50;
        }
        // Update volume icon
        const volume = spotifyPlayback.device ? spotifyPlayback.device.volume_percent : 50;
        const volumeIcon = document.getElementById('spotifyMiniVolumeIcon');
        if (volumeIcon) {
            volumeIcon.src = `/icon/${getVolumeIcon(volume)}`;
        }
    }

    // Update device name
    const deviceName = document.getElementById('spotifyMiniDeviceName');
    if (deviceName && spotifyPlayback.device) {
        deviceName.textContent = spotifyPlayback.device.name || 'Unknown';
    }

    // Update progress bar
    updateMiniPlayerProgress();

    // Update screensaver display
    if (typeof Screensaver !== 'undefined') {
        Screensaver.updateSpotify(spotifyPlayback);
    }
}

function updateMiniPlayerProgress() {
    const progressFill = document.getElementById('spotifyMiniProgressFill');
    if (!progressFill || !spotifyPlayback || !spotifyPlayback.item) return;

    const progress = spotifyPlayback.progress_ms || 0;
    const duration = spotifyPlayback.item.duration_ms || 1;
    const percent = (progress / duration) * 100;
    progressFill.style.width = `${percent}%`;
}

function handleMiniPlayerClick(event) {
    // Open the full modal when clicking on empty area (not on controls)
    openSpotifyModal();
}

function openSpotifyModal() {
    if (!spotifyStatus || !spotifyStatus.authenticated) {
        window.location.href = '/auth/spotify';
        return;
    }

    document.getElementById('spotifyModal').classList.add('active');
    loadSpotifyDevices();
    loadSpotifyPlaylists();
    loadRecentTracks();
    loadTopArtists();
    loadTopTracks();
    renderSpotifyContent();
    startSpotifyProgressUpdates();
}

function closeSpotifyModal() {
    document.getElementById('spotifyModal').classList.remove('active');
    stopSpotifyProgressUpdates();
}

function startSpotifyProgressUpdates() {
    // No longer needed - startMiniPlayerProgress() handles all progress updates
    // Keeping function for compatibility with openSpotifyModal()
}

function stopSpotifyProgressUpdates() {
    // No longer needed - startMiniPlayerProgress() handles all progress updates
}

function updateProgressBar() {
    const progressBar = document.getElementById('spotifyProgressBar');
    const currentTime = document.getElementById('spotifyCurrentTime');
    const totalTime = document.getElementById('spotifyTotalTime');

    if (!progressBar || !spotifyPlayback || !spotifyPlayback.item) return;

    const progress = spotifyPlayback.progress_ms || 0;
    const duration = spotifyPlayback.item.duration_ms || 1;
    const percent = (progress / duration) * 100;

    progressBar.style.width = `${percent}%`;
    if (currentTime) currentTime.textContent = formatTime(progress);
    if (totalTime) totalTime.textContent = formatTime(duration);
}

function formatTime(ms) {
    const seconds = Math.floor(ms / 1000);
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

let activeSpotifyBrowseTab = 'home';
let spotifyRecentItems = [];
let spotifyTopArtists = [];
let spotifyTopTracks = [];
let spotifyDetailView = null; // Current detail view: { type: 'album'|'artist'|'section', data: {...} }
let spotifyDetailHistory = []; // Navigation history stack
let spotifySectionData = {}; // Store section data for "Show all"

// Library tab state
let libraryFilter = 'all'; // 'all', 'playlists', 'artists', 'albums', 'shows'
let librarySort = 'recents'; // 'recents', 'alphabetical', 'creator'
let librarySearch = '';
let libraryAlbums = [];
let libraryArtists = [];
let libraryShows = [];
let likedSongsTotal = 0;
let libraryLoaded = false;

function renderSpotifyContent() {
    const content = document.getElementById('spotifyModalContent');

    if (!spotifyStatus || !spotifyStatus.authenticated) {
        content.innerHTML = `
            <div class="spotify-auth-prompt">
                <p>Connect your Spotify account to control playback</p>
                <a href="/auth/spotify" class="modal-btn primary">Connect Spotify</a>
            </div>`;
        return;
    }

    // Split layout: left (now playing) + right (search/browse)
    let html = `
        <div class="spotify-split-layout">
            <div class="spotify-left-panel">
                ${renderNowPlayingPanel()}
            </div>
            <div class="spotify-right-panel">
                <div class="spotify-search-bar">
                    <img src="/icon/magnifying-glass" class="spotify-search-icon" alt="">
                    <input type="text" id="spotifySearchInput" class="spotify-search-input"
                           placeholder="What do you want to listen to?"
                           onfocus="activateKeyboard(this, performSpotifySearch)"
                           onkeydown="if(event.key==='Enter'){performSpotifySearch();hideKeyboard();}"
                           oninput="toggleSearchClear()">
                    <button class="spotify-search-clear" id="spotifySearchClear" onclick="clearSpotifySearch()" style="display:none;">
                        <img src="/icon/xmark" alt="Clear">
                    </button>
                </div>
                <div class="spotify-browse-tabs">
                    <button class="spotify-browse-tab ${activeSpotifyBrowseTab === 'home' ? 'active' : ''}" onclick="switchSpotifyBrowseTab('home')">Home</button>
                    <button class="spotify-browse-tab ${activeSpotifyBrowseTab === 'library' ? 'active' : ''}" onclick="switchSpotifyBrowseTab('library')">Library</button>
                </div>
                <div class="spotify-browse-content" id="spotifyBrowseContent">
                    ${renderBrowseContent()}
                </div>
            </div>
        </div>`;

    content.innerHTML = html;
    updateProgressBar();
}

function renderNowPlayingPanel() {
    if (!spotifyPlayback || !spotifyPlayback.item) {
        const deviceName = spotifyPlayback?.device?.name || 'No device';
        return `
            <div class="spotify-now-playing-panel">
                <div class="spotify-no-playback">
                    <img src="/icon/spotify" class="spotify-no-playback-icon" alt="">
                    <p>No active playback</p>
                    <p class="spotify-hint">Start playing on any device</p>
                </div>
                <button class="spotify-device-btn" onclick="openSpotifyDeviceModal()">
                    <img src="/icon/volume-high" alt="">
                    <span>${escapeHtml(deviceName)}</span>
                </button>
            </div>`;
    }

    const track = spotifyPlayback.item;
    const album = track.album || {};
    const artistsList = track.artists || [];
    const artistsDisplay = artistsList.map(a => a.name).join(', ');
    const albumArt = album.images && album.images.length > 0 ? album.images[0].url : '';
    const isPlaying = spotifyPlayback.is_playing;
    const shuffleActive = spotifyPlayback.shuffle_state ? 'active' : '';
    const repeatState = spotifyPlayback.repeat_state || 'off';
    const repeatActive = repeatState !== 'off' ? 'active' : '';
    const volume = spotifyPlayback.device ? spotifyPlayback.device.volume_percent : 50;
    const deviceName = spotifyPlayback.device?.name || 'Unknown device';
    const albumId = album.id || '';
    const firstArtist = artistsList[0];

    // Build clickable artist links
    const artistLinks = artistsList.map(a =>
        `<span class="spotify-artist-link" onclick="openArtistDetail('${a.id}')">${escapeHtml(a.name)}</span>`
    ).join(', ');

    return `
        <div class="spotify-now-playing-panel">
            <div class="spotify-album-art" ${albumId ? `onclick="openAlbumDetail('${albumId}')" style="cursor:pointer"` : ''}>
                ${albumArt ? `<img src="${albumArt}" alt="${escapeHtml(album.name || '')}">` : '<div class="spotify-no-art"></div>'}
            </div>
            <div class="spotify-track-info">
                <div class="spotify-track-name">${escapeHtml(track.name)}</div>
                <div class="spotify-track-artist">${artistLinks}</div>
            </div>
            <div class="spotify-progress">
                <span class="spotify-time" id="spotifyCurrentTime">${formatTime(spotifyPlayback.progress_ms || 0)}</span>
                <div class="spotify-progress-bar" onclick="seekSpotify(event)">
                    <div class="spotify-progress-fill" id="spotifyProgressBar"></div>
                </div>
                <span class="spotify-time" id="spotifyTotalTime">${formatTime(track.duration_ms || 0)}</span>
            </div>
            <div class="spotify-controls">
                <button class="spotify-control-btn spotify-secondary ${shuffleActive}" onclick="toggleSpotifyShuffle()">
                    <img src="/icon/shuffle" alt="Shuffle">
                </button>
                <button class="spotify-control-btn" onclick="spotifyPrevious()">
                    <img src="/icon/backward-step" alt="Previous">
                </button>
                <button class="spotify-control-btn spotify-play-btn" onclick="toggleSpotifyPlayback()">
                    <img src="/icon/${isPlaying ? 'pause' : 'play'}" alt="${isPlaying ? 'Pause' : 'Play'}">
                </button>
                <button class="spotify-control-btn" onclick="spotifyNext()">
                    <img src="/icon/forward-step" alt="Next">
                </button>
                <button class="spotify-control-btn spotify-secondary ${repeatActive}" onclick="toggleSpotifyRepeat()">
                    <img src="/icon/repeat" alt="Repeat">
                </button>
            </div>
            <div class="spotify-volume">
                <img src="/icon/${getVolumeIcon(volume)}" class="spotify-volume-icon" alt="Volume" onclick="toggleMute()" style="cursor:pointer">
                <input type="range" class="spotify-volume-slider" min="0" max="100" value="${volume}"
                       oninput="onVolumeInput(this)">
                <span class="spotify-volume-value">${volume}%</span>
            </div>
            <button class="spotify-device-btn" onclick="openSpotifyDeviceModal()">
                <img src="/icon/speaker" alt="">
                <span>${escapeHtml(deviceName)}</span>
            </button>
        </div>`;
}

function renderBrowseContent() {
    // Check if we're showing a detail view
    if (spotifyDetailView) {
        return renderDetailView();
    }

    if (activeSpotifyBrowseTab === 'home') {
        return renderHomeContent();
    } else {
        return renderLibraryContent();
    }
}

function renderDetailView() {
    const { type, data } = spotifyDetailView;

    let html = `
        <div class="spotify-detail-inline">
            <button class="spotify-back-btn" onclick="goBackFromDetail()">
                <img src="/icon/circle-arrow-left" alt="Back">
                <span>Back</span>
            </button>`;

    if (type === 'album') {
        html += renderAlbumDetailInline(data);
    } else if (type === 'artist') {
        html += renderArtistDetailInline(data.artist, data.albums, data.topTracks || []);
    } else if (type === 'section') {
        html += renderSectionViewInline(data.title, data.items, data.roundImages);
    } else if (type === 'liked-songs') {
        html += renderLikedSongsInline(data.tracks, data.total);
    }

    html += `</div>`;
    return html;
}

function renderSectionViewInline(title, items, roundImages) {
    let html = `
        <div class="spotify-section-view">
            <h2 class="spotify-section-view-title">${escapeHtml(title)}</h2>
            <div class="spotify-section-grid">`;

    items.forEach(item => {
        const imageClass = roundImages || item.round ? 'round' : '';
        const clickAction = getItemClickAction(item);
        html += `
            <div class="spotify-home-card" onclick="${clickAction}">
                <div class="spotify-home-card-image ${imageClass}">
                    ${item.image ? `<img src="${item.image}" alt="">` : '<div class="spotify-no-art"></div>'}
                    <button class="spotify-play-overlay" onclick="event.stopPropagation(); playSpotifyUri('${item.uri}')">
                        <img src="/icon/play" alt="Play">
                    </button>
                </div>
                <div class="spotify-home-card-name">${escapeHtml(item.name)}</div>
                <div class="spotify-home-card-subtitle">${escapeHtml(item.subtitle)}</div>
            </div>`;
    });

    html += `</div></div>`;
    return html;
}

function openSectionView(title) {
    const sectionData = spotifySectionData[title];
    if (!sectionData) return;

    // Save current view to history
    if (spotifyDetailView) {
        spotifyDetailHistory.push(spotifyDetailView);
    }

    spotifyDetailView = {
        type: 'section',
        data: {
            title: title,
            items: sectionData.items,
            roundImages: sectionData.roundImages
        }
    };

    const browseContent = document.getElementById('spotifyBrowseContent');
    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
}

function renderAlbumDetailInline(album) {
    const image = album.images?.[0]?.url || '';
    const year = album.release_date?.split('-')[0] || '';
    const totalTracks = album.total_tracks || album.tracks?.total || 0;

    // Build clickable artist links
    const artistLinks = album.artists?.map(a =>
        `<span class="spotify-album-artist-link" onclick="event.stopPropagation(); openArtistDetail('${a.id}')">${escapeHtml(a.name)}</span>`
    ).join(', ') || '';

    // Calculate total duration
    let totalDurationMs = 0;
    if (album.tracks?.items) {
        album.tracks.items.forEach(track => {
            totalDurationMs += track.duration_ms || 0;
        });
    }
    const totalMins = Math.floor(totalDurationMs / 60000);

    // Build tracks HTML with now-playing support
    let tracksHtml = '';
    const currentTrackUri = spotifyPlayback?.item?.uri;
    const isPlaying = spotifyPlayback?.is_playing;

    if (album.tracks?.items) {
        album.tracks.items.forEach((track, index) => {
            const isCurrentTrack = track.uri === currentTrackUri;
            const nowPlayingClass = isCurrentTrack ? ' now-playing' : '';
            const trackIndicator = isCurrentTrack && isPlaying
                ? `<img src="/icon/playing" class="now-playing-icon" alt="Playing">`
                : `${index + 1}`;

            tracksHtml += `
                <div class="spotify-album-track${nowPlayingClass}" onclick="playAlbumTrack('${album.uri}', ${index})" data-track-uri="${track.uri}">
                    <span class="spotify-album-track-num">${trackIndicator}</span>
                    <div class="spotify-album-track-info">
                        <div class="spotify-album-track-name">${escapeHtml(track.name)}</div>
                    </div>
                    <span class="spotify-album-track-duration">${formatTime(track.duration_ms)}</span>
                </div>`;
        });
    }

    return `
        <div class="spotify-album-detail-layout">
            <div class="spotify-album-detail-left">
                <div class="spotify-album-image-large">
                    ${image ? `<img src="${image}" alt="">` : ''}
                </div>
                <div class="spotify-album-info">
                    <div class="spotify-detail-type">Album</div>
                    <div class="spotify-album-name-large">${escapeHtml(album.name)}</div>
                    <div class="spotify-album-artists">${artistLinks}</div>
                    <div class="spotify-album-meta">${year} â€¢ ${totalTracks} songs â€¢ ${totalMins} min</div>
                </div>
                <div class="spotify-album-actions">
                    <button class="spotify-play-btn" onclick="playSpotifyUri('${album.uri}')">
                        <img src="/icon/play" alt="">
                        Play
                    </button>
                    <button class="spotify-shuffle-btn" onclick="shufflePlay('${album.uri}')">
                        <img src="/icon/shuffle" alt="">
                        Shuffle
                    </button>
                </div>
                <div class="spotify-secondary-actions">
                    <button class="spotify-save-btn" id="albumSaveBtn-${album.id}" onclick="toggleAlbumSaved('${album.id}')" title="Save to Library">
                        <img src="/icon/heart" alt="" id="albumSaveIcon-${album.id}">
                    </button>
                </div>
            </div>
            <div class="spotify-album-detail-right">
                <div class="spotify-album-tracklist">${tracksHtml}</div>
            </div>
        </div>
    `;
}

function renderArtistDetailInline(artist, albums, topTracks) {
    const image = artist.images?.[0]?.url || '';
    const followers = artist.followers?.total ? formatNumber(artist.followers.total) + ' followers' : '';
    const genres = artist.genres?.slice(0, 3).join(', ') || '';

    // Build top tracks HTML (limit to 10)
    let topTracksHtml = '';
    const currentTrackUri = spotifyPlayback?.item?.uri;
    const isPlaying = spotifyPlayback?.is_playing;

    topTracks.slice(0, 10).forEach((track, index) => {
        const trackImage = track.album?.images?.[2]?.url || track.album?.images?.[0]?.url || '';
        const duration = formatTime(track.duration_ms);
        const isCurrentTrack = track.uri === currentTrackUri;
        const nowPlayingClass = isCurrentTrack ? ' now-playing' : '';
        const trackIndicator = isCurrentTrack && isPlaying
            ? `<img src="/icon/playing" class="now-playing-icon" alt="Playing">`
            : `${index + 1}`;

        topTracksHtml += `
            <div class="spotify-artist-track${nowPlayingClass}" onclick="playSpotifyUri('${track.uri}')" data-track-uri="${track.uri}">
                <span class="spotify-artist-track-num">${trackIndicator}</span>
                <div class="spotify-artist-track-image">
                    ${trackImage ? `<img src="${trackImage}" alt="">` : ''}
                </div>
                <div class="spotify-artist-track-info">
                    <div class="spotify-artist-track-name">${escapeHtml(track.name)}</div>
                </div>
                <span class="spotify-artist-track-duration">${duration}</span>
            </div>`;
    });

    // Build albums HTML
    let albumsHtml = '';
    albums.forEach(album => {
        const albumImage = album.images?.[1]?.url || album.images?.[0]?.url || '';
        const year = album.release_date ? album.release_date.substring(0, 4) : '';
        albumsHtml += `
            <div class="spotify-artist-album" onclick="openAlbumDetail('${album.id}')">
                <div class="spotify-artist-album-image">
                    ${albumImage ? `<img src="${albumImage}" alt="">` : ''}
                </div>
                <div class="spotify-artist-album-info">
                    <div class="spotify-artist-album-name">${escapeHtml(album.name)}</div>
                    <div class="spotify-artist-album-year">${year}</div>
                </div>
            </div>`;
    });

    return `
        <div class="spotify-artist-detail-layout">
            <div class="spotify-artist-detail-left">
                <div class="spotify-artist-image-large">
                    ${image ? `<img src="${image}" alt="">` : ''}
                </div>
                <div class="spotify-artist-info">
                    <div class="spotify-detail-type">Artist</div>
                    <div class="spotify-artist-name-large">${escapeHtml(artist.name)}</div>
                    <div class="spotify-artist-genres">${escapeHtml(genres)}</div>
                    <div class="spotify-artist-followers">${followers}</div>
                </div>
                <div class="spotify-artist-actions">
                    <button class="spotify-play-btn" onclick="playSpotifyUri('${artist.uri}')">
                        <img src="/icon/play" alt="">
                        Play
                    </button>
                    <button class="spotify-shuffle-btn" onclick="shufflePlay('${artist.uri}')">
                        <img src="/icon/shuffle" alt="">
                        Shuffle
                    </button>
                </div>
                <div class="spotify-secondary-actions">
                    <button class="spotify-follow-btn" id="artistFollowBtn-${artist.id}" onclick="toggleArtistFollow('${artist.id}')" title="Follow">
                        <img src="/icon/user-plus" alt="" id="artistFollowIcon-${artist.id}">
                    </button>
                </div>
            </div>
            <div class="spotify-artist-detail-right">
                <div class="spotify-artist-section">
                    <div class="spotify-detail-section-title">Popular</div>
                    <div class="spotify-artist-top-tracks">${topTracksHtml}</div>
                </div>
                <div class="spotify-artist-section">
                    <div class="spotify-detail-section-title">Discography</div>
                    <div class="spotify-artist-albums">${albumsHtml}</div>
                </div>
            </div>
        </div>
    `;
}

function renderLikedSongsInline(tracks, total) {
    const currentTrackUri = spotifyPlayback?.item?.uri;
    const isPlaying = spotifyPlayback?.is_playing;

    let tracksHtml = '';
    tracks.forEach((saved, index) => {
        const track = saved.track;
        const trackImage = track.album?.images?.[2]?.url || track.album?.images?.[0]?.url || '';
        const isCurrentTrack = track.uri === currentTrackUri;
        const nowPlayingClass = isCurrentTrack ? ' now-playing' : '';
        const trackIndicator = isCurrentTrack && isPlaying
            ? `<img src="/icon/playing" class="now-playing-icon" alt="Playing">`
            : `${index + 1}`;

        tracksHtml += `
            <div class="spotify-liked-track${nowPlayingClass}" onclick="playSpotifyUri('${track.uri}')" data-track-uri="${track.uri}">
                <span class="spotify-liked-track-num">${trackIndicator}</span>
                <div class="spotify-liked-track-image">
                    ${trackImage ? `<img src="${trackImage}" alt="">` : ''}
                </div>
                <div class="spotify-liked-track-info">
                    <div class="spotify-liked-track-name">${escapeHtml(track.name)}</div>
                    <div class="spotify-liked-track-artist">${track.artists?.map(a => a.name).join(', ') || ''}</div>
                </div>
                <div class="spotify-liked-track-album">${escapeHtml(track.album?.name || '')}</div>
                <span class="spotify-liked-track-duration">${formatTime(track.duration_ms)}</span>
            </div>`;
    });

    return `
        <div class="spotify-liked-songs-layout">
            <div class="spotify-liked-songs-header">
                <div class="spotify-liked-songs-image">
                    <div class="spotify-liked-songs-gradient"></div>
                    <img src="/icon/heart-solid" alt="" class="spotify-liked-songs-icon">
                </div>
                <div class="spotify-liked-songs-info">
                    <div class="spotify-detail-type">Playlist</div>
                    <div class="spotify-liked-songs-title">Liked Songs</div>
                    <div class="spotify-liked-songs-count">${total} songs</div>
                </div>
                <div class="spotify-liked-songs-actions">
                    <button class="spotify-play-btn" onclick="playLikedSongs()">
                        <img src="/icon/play" alt="">
                        Play
                    </button>
                    <button class="spotify-shuffle-btn" onclick="shuffleLikedSongs()">
                        <img src="/icon/shuffle" alt="">
                        Shuffle
                    </button>
                </div>
            </div>
            <div class="spotify-liked-songs-tracks">
                ${tracksHtml}
            </div>
        </div>
    `;
}

async function playLikedSongs() {
    // Play the first liked song
    try {
        const resp = await fetch('/api/spotify/library/tracks?limit=1');
        if (resp.ok) {
            const data = await resp.json();
            if (data.items && data.items.length > 0) {
                playSpotifyUri(data.items[0].track.uri);
            }
        }
    } catch (err) {
        console.error('Failed to play liked songs:', err);
    }
}

async function shuffleLikedSongs() {
    // Enable shuffle and play the first liked song
    try {
        await fetch('/api/spotify/shuffle', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: true })
        });

        const resp = await fetch('/api/spotify/library/tracks?limit=1');
        if (resp.ok) {
            const data = await resp.json();
            if (data.items && data.items.length > 0) {
                playSpotifyUri(data.items[0].track.uri);
            }
        }
    } catch (err) {
        console.error('Failed to shuffle liked songs:', err);
    }
}

function goBackFromDetail() {
    const browseContent = document.getElementById('spotifyBrowseContent');

    // Check if there's history to go back to
    if (spotifyDetailHistory.length > 0) {
        spotifyDetailView = spotifyDetailHistory.pop();
    } else {
        spotifyDetailView = null;
    }

    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
}

function renderHomeContent() {
    let html = `<div class="spotify-home-content">`;

    // Recently Played Section - shows individual tracks (deduplicated)
    if (spotifyRecentItems.length > 0) {
        const seen = new Set();
        const recent = spotifyRecentItems
            .map(item => ({
                type: 'track',
                id: item.track.id,
                name: item.track.name,
                subtitle: item.track.artists?.map(a => a.name).join(', ') || '',
                image: item.track.album?.images?.[0]?.url || '',
                uri: item.track.uri,
                albumId: item.track.album?.id
            }))
            .filter(item => {
                if (!item.id || seen.has(item.id)) return false;
                seen.add(item.id);
                return true;
            });
        html += renderSection('Recently Played', recent, false);
    }

    // Your Top Artists Section
    if (spotifyTopArtists.length > 0) {
        const artists = spotifyTopArtists.map(artist => ({
            type: 'artist',
            id: artist.id,
            name: artist.name,
            subtitle: 'Artist',
            image: artist.images?.[0]?.url || '',
            uri: artist.uri,
            round: true
        }));
        html += renderSection('Your Top Artists', artists, true);
    }

    // Your Playlists Section
    if (spotifyPlaylists.length > 0) {
        const playlists = spotifyPlaylists.map(playlist => ({
            type: 'playlist',
            id: playlist.id,
            name: playlist.name,
            subtitle: `${playlist.tracks.total} songs`,
            image: playlist.images?.[0]?.url || '',
            uri: playlist.uri
        }));
        html += renderSection('Your Playlists', playlists, false);
    }

    // Jump Back In - shows unique albums from top tracks
    if (spotifyTopTracks.length > 0) {
        const seen = new Set();
        const topAlbums = [];

        spotifyTopTracks.forEach(track => {
            const albumId = track.album?.id;
            if (albumId && !seen.has(albumId)) {
                seen.add(albumId);
                topAlbums.push({
                    type: 'album',
                    id: albumId,
                    name: track.album.name,
                    subtitle: track.album.artists?.[0]?.name || track.artists?.map(a => a.name).join(', ') || '',
                    image: track.album.images?.[0]?.url || '',
                    uri: track.album.uri
                });
            }
        });

        if (topAlbums.length > 0) {
            html += renderSection('Jump Back In', topAlbums, false);
        }
    }

    html += `</div>`;

    if (html === `<div class="spotify-home-content"></div>`) {
        return `<div class="spotify-browse-empty">
            <p>Loading your music...</p>
            <p class="spotify-hint">Your personalized content will appear here</p>
        </div>`;
    }

    return html;
}

function renderSection(title, items, roundImages) {
    // Store all items for "Show all" functionality
    spotifySectionData[title] = { items: items, roundImages: roundImages };

    // Limit to 10 items in the row
    const displayItems = items.slice(0, 10);
    const hasMore = items.length > 10;

    // Escape title for use in onclick
    const escapedTitle = title.replace(/'/g, "\\'").replace(/"/g, '\\"');

    let html = `
        <div class="spotify-home-section">
            <div class="spotify-section-header">
                <h4 class="spotify-section-title">${escapeHtml(title)}</h4>
                ${hasMore ? `<span class="spotify-section-showall" onclick="openSectionView('${escapedTitle}')">Show all</span>` : ''}
            </div>
            <div class="spotify-scroll-row">`;

    displayItems.forEach(item => {
        const imageClass = roundImages || item.round ? 'round' : '';
        const clickAction = getItemClickAction(item);
        html += `
            <div class="spotify-home-card" onclick="${clickAction}">
                <div class="spotify-home-card-image ${imageClass}">
                    ${item.image ? `<img src="${item.image}" alt="">` : '<div class="spotify-no-art"></div>'}
                    <button class="spotify-play-overlay" onclick="event.stopPropagation(); playSpotifyUri('${item.uri}')">
                        <img src="/icon/play" alt="Play">
                    </button>
                </div>
                <div class="spotify-home-card-name">${escapeHtml(item.name)}</div>
                <div class="spotify-home-card-subtitle">${escapeHtml(item.subtitle)}</div>
            </div>`;
    });

    html += `</div></div>`;
    return html;
}

function getItemClickAction(item) {
    switch (item.type) {
        case 'album':
            return `openAlbumDetail('${item.id}')`;
        case 'artist':
            return `openArtistDetail('${item.id}')`;
        case 'playlist':
            return `openPlaylist('${item.id}', '${escapeHtml(item.name).replace(/'/g, "\\'")}')`;
        case 'track':
            // For tracks, open the album detail
            return item.albumId ? `openAlbumDetail('${item.albumId}')` : `playSpotifyUri('${item.uri}')`;
        default:
            return `playSpotifyUri('${item.uri}')`;
    }
}

function renderLibraryContent() {
    // Load library data if not loaded
    if (!libraryLoaded) {
        loadLibraryData();
        return `<div class="spotify-loading">Loading library...</div>`;
    }

    // Build all library items
    let allItems = buildLibraryItems();

    // Filter by type
    if (libraryFilter !== 'all') {
        allItems = allItems.filter(item => item.filterType === libraryFilter);
    }

    // Filter by search
    if (librarySearch) {
        const search = librarySearch.toLowerCase();
        allItems = allItems.filter(item =>
            item.name.toLowerCase().includes(search) ||
            (item.subtitle && item.subtitle.toLowerCase().includes(search))
        );
    }

    // Sort items
    allItems = sortLibraryItems(allItems, librarySort);

    let html = `
        <div class="spotify-library-container">
            <div class="spotify-library-filters">
                <button class="spotify-filter-pill ${libraryFilter === 'all' ? 'active' : ''}" onclick="setLibraryFilter('all')">All</button>
                <button class="spotify-filter-pill ${libraryFilter === 'playlists' ? 'active' : ''}" onclick="setLibraryFilter('playlists')">Playlists</button>
                <button class="spotify-filter-pill ${libraryFilter === 'artists' ? 'active' : ''}" onclick="setLibraryFilter('artists')">Artists</button>
                <button class="spotify-filter-pill ${libraryFilter === 'albums' ? 'active' : ''}" onclick="setLibraryFilter('albums')">Albums</button>
                <button class="spotify-filter-pill ${libraryFilter === 'shows' ? 'active' : ''}" onclick="setLibraryFilter('shows')">Podcasts & Shows</button>
            </div>
            <div class="spotify-library-controls">
                <div class="spotify-library-search">
                    <img src="/icon/magnifying-glass" alt="" class="spotify-library-search-icon">
                    <input type="text" placeholder="Search in Your Library" value="${escapeHtml(librarySearch)}"
                           oninput="setLibrarySearch(this.value)" class="spotify-library-search-input">
                    ${librarySearch ? `<button class="spotify-library-search-clear" onclick="setLibrarySearch('')"><img src="/icon/xmark" alt=""></button>` : ''}
                </div>
                <div class="spotify-library-sort">
                    <select onchange="setLibrarySort(this.value)" class="spotify-library-sort-select">
                        <option value="recents" ${librarySort === 'recents' ? 'selected' : ''}>Recents</option>
                        <option value="alphabetical" ${librarySort === 'alphabetical' ? 'selected' : ''}>Alphabetical</option>
                        <option value="creator" ${librarySort === 'creator' ? 'selected' : ''}>Creator</option>
                    </select>
                </div>
            </div>
            <div class="spotify-library-grid">`;

    // Render items
    allItems.forEach(item => {
        const roundClass = item.type === 'artist' ? ' round' : '';
        html += `
            <div class="spotify-library-item${roundClass}" onclick="${item.onclick}">
                <div class="spotify-library-item-image${roundClass}">
                    ${item.image ? `<img src="${item.image}" alt="">` : `<div class="spotify-no-art${roundClass}"></div>`}
                    ${item.type === 'liked' ? '<div class="spotify-liked-songs-gradient"></div>' : ''}
                </div>
                <div class="spotify-library-item-info">
                    <div class="spotify-library-item-name">${escapeHtml(item.name)}</div>
                    <div class="spotify-library-item-meta">${escapeHtml(item.subtitle)}</div>
                </div>
            </div>`;
    });

    html += `</div></div>`;
    return html;
}

function buildLibraryItems() {
    const items = [];

    // Add Liked Songs first (always)
    items.push({
        type: 'liked',
        filterType: 'playlists',
        name: 'Liked Songs',
        subtitle: `Playlist â€¢ ${likedSongsTotal} songs`,
        image: '',
        onclick: `openLikedSongs()`,
        addedAt: new Date().toISOString(), // Always at top for recents
        creator: ''
    });

    // Add playlists
    spotifyPlaylists.forEach(playlist => {
        items.push({
            type: 'playlist',
            filterType: 'playlists',
            name: playlist.name,
            subtitle: `Playlist â€¢ ${playlist.owner?.display_name || ''}`,
            image: playlist.images?.[0]?.url || '',
            onclick: `openPlaylist('${playlist.id}', '${escapeHtml(playlist.name).replace(/'/g, "\\'")}')`,
            addedAt: '', // Playlists don't have addedAt
            creator: playlist.owner?.display_name || ''
        });
    });

    // Add albums
    libraryAlbums.forEach(saved => {
        const album = saved.album;
        items.push({
            type: 'album',
            filterType: 'albums',
            name: album.name,
            subtitle: `Album â€¢ ${album.artists?.map(a => a.name).join(', ') || ''}`,
            image: album.images?.[0]?.url || '',
            onclick: `openAlbumDetail('${album.id}')`,
            addedAt: saved.added_at || '',
            creator: album.artists?.[0]?.name || ''
        });
    });

    // Add artists
    libraryArtists.forEach(artist => {
        items.push({
            type: 'artist',
            filterType: 'artists',
            name: artist.name,
            subtitle: 'Artist',
            image: artist.images?.[0]?.url || '',
            onclick: `openArtistDetail('${artist.id}')`,
            addedAt: '', // Artists don't have addedAt
            creator: artist.name
        });
    });

    // Add shows
    libraryShows.forEach(saved => {
        const show = saved.show;
        items.push({
            type: 'show',
            filterType: 'shows',
            name: show.name,
            subtitle: `Podcast â€¢ ${show.publisher || ''}`,
            image: show.images?.[0]?.url || '',
            onclick: `openShow('${show.id}')`,
            addedAt: saved.added_at || '',
            creator: show.publisher || ''
        });
    });

    return items;
}

function sortLibraryItems(items, sortBy) {
    // Always keep Liked Songs first
    const likedSongs = items.filter(i => i.type === 'liked');
    const rest = items.filter(i => i.type !== 'liked');

    switch (sortBy) {
        case 'alphabetical':
            rest.sort((a, b) => a.name.localeCompare(b.name));
            break;
        case 'creator':
            rest.sort((a, b) => (a.creator || '').localeCompare(b.creator || ''));
            break;
        case 'recents':
        default:
            // Sort by addedAt date (most recent first), items without dates go to end
            rest.sort((a, b) => {
                if (!a.addedAt && !b.addedAt) return 0;
                if (!a.addedAt) return 1;
                if (!b.addedAt) return -1;
                return new Date(b.addedAt) - new Date(a.addedAt);
            });
            break;
    }

    return [...likedSongs, ...rest];
}

async function loadLibraryData() {
    try {
        const [albumsResp, artistsResp, tracksResp, showsResp] = await Promise.all([
            fetch('/api/spotify/library/albums?limit=50'),
            fetch('/api/spotify/library/artists?limit=50'),
            fetch('/api/spotify/library/tracks?limit=1'), // Just get total count
            fetch('/api/spotify/library/shows?limit=50')
        ]);

        if (albumsResp.ok) {
            const data = await albumsResp.json();
            libraryAlbums = data.items || [];
        }
        if (artistsResp.ok) {
            const data = await artistsResp.json();
            libraryArtists = data.items || [];
        }
        if (tracksResp.ok) {
            const data = await tracksResp.json();
            likedSongsTotal = data.total || 0;
        }
        if (showsResp.ok) {
            const data = await showsResp.json();
            libraryShows = data.items || [];
        }

        libraryLoaded = true;

        // Re-render if still on library tab
        if (activeSpotifyBrowseTab === 'library') {
            const browseContent = document.getElementById('spotifyBrowseContent');
            if (browseContent) {
                browseContent.innerHTML = renderBrowseContent();
            }
        }
    } catch (err) {
        console.error('Failed to load library data:', err);
    }
}

function setLibraryFilter(filter) {
    libraryFilter = filter;
    const browseContent = document.getElementById('spotifyBrowseContent');
    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
}

function setLibrarySort(sort) {
    librarySort = sort;
    const browseContent = document.getElementById('spotifyBrowseContent');
    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
}

function setLibrarySearch(search) {
    librarySearch = search;
    const browseContent = document.getElementById('spotifyBrowseContent');
    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
}

async function openLikedSongs() {
    const browseContent = document.getElementById('spotifyBrowseContent');

    if (spotifyDetailView) {
        spotifyDetailHistory.push(spotifyDetailView);
    }

    browseContent.innerHTML = '<div class="spotify-loading">Loading liked songs...</div>';

    try {
        const resp = await fetch('/api/spotify/library/tracks?limit=50');
        if (resp.ok) {
            const data = await resp.json();
            spotifyDetailView = {
                type: 'liked-songs',
                data: {
                    tracks: data.items || [],
                    total: data.total || 0
                }
            };
            browseContent.innerHTML = renderBrowseContent();
        } else {
            browseContent.innerHTML = '<div class="spotify-error">Failed to load liked songs</div>';
        }
    } catch (err) {
        console.error('Failed to load liked songs:', err);
        browseContent.innerHTML = '<div class="spotify-error">Failed to load liked songs</div>';
    }
}

function openShow(showId) {
    // Placeholder for show detail - could be implemented later
    console.log('Open show:', showId);
}

function switchSpotifyBrowseTab(tab) {
    activeSpotifyBrowseTab = tab;
    spotifyDetailView = null; // Clear detail view when switching tabs
    spotifyDetailHistory = []; // Clear navigation history
    const browseContent = document.getElementById('spotifyBrowseContent');
    if (browseContent) {
        browseContent.innerHTML = renderBrowseContent();
    }
    // Update tab buttons
    document.querySelectorAll('.spotify-browse-tab').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase() === tab);
    });
}

// Device modal functions
function openSpotifyDeviceModal() {
    document.getElementById('spotifyDeviceModal').classList.add('active');
    renderDeviceModalContent();
}

function closeSpotifyDeviceModal() {
    document.getElementById('spotifyDeviceModal').classList.remove('active');
    // Clear pending play state if modal closed without selecting a device
    pendingPlayUri = null;
    pendingShufflePlay = false;
}

function renderDeviceModalContent() {
    const content = document.getElementById('spotifyDeviceContent');

    if (spotifyDevices.length === 0) {
        content.innerHTML = `
            <div class="spotify-no-devices">
                <p>No devices found</p>
                <p class="spotify-hint">Open Spotify on a device to see it here</p>
                <button class="modal-btn secondary" onclick="loadSpotifyDevices().then(renderDeviceModalContent)">Refresh</button>
            </div>`;
        return;
    }

    let html = `<div class="spotify-devices-list">`;
    spotifyDevices.forEach(device => {
        const isActive = device.is_active ? 'active' : '';
        const icon = getDeviceIcon(device.type);
        html += `
            <div class="spotify-device ${isActive}" onclick="transferToDevice('${device.id}'); closeSpotifyDeviceModal();">
                <div class="spotify-device-icon">${icon}</div>
                <div class="spotify-device-info">
                    <div class="spotify-device-name">${escapeHtml(device.name)}</div>
                    <div class="spotify-device-type">${device.type}${device.is_active ? ' - Active' : ''}</div>
                </div>
                ${device.is_active ? '<div class="spotify-device-active-indicator"></div>' : ''}
            </div>`;
    });
    html += `</div>`;
    content.innerHTML = html;
}

// Album detail functions (inline)
async function openAlbumDetail(albumId) {
    const browseContent = document.getElementById('spotifyBrowseContent');

    // Save current view to history if we're navigating from another detail view
    if (spotifyDetailView) {
        spotifyDetailHistory.push(spotifyDetailView);
    }

    browseContent.innerHTML = '<div class="spotify-loading">Loading album...</div>';

    try {
        const resp = await fetch(`/api/spotify/album/${albumId}`);
        if (resp.ok) {
            const album = await resp.json();
            spotifyDetailView = { type: 'album', data: album };
            browseContent.innerHTML = renderBrowseContent();
            // Check if album is saved and update button
            checkAlbumSaved(albumId);
        } else {
            browseContent.innerHTML = '<div class="spotify-error">Failed to load album</div>';
        }
    } catch (err) {
        console.error('Failed to load album:', err);
        browseContent.innerHTML = '<div class="spotify-error">Failed to load album</div>';
    }
}

// Track album saved states
let albumSavedStates = {};

async function checkAlbumSaved(albumId) {
    try {
        const resp = await fetch(`/api/spotify/album/${albumId}/saved`);
        if (resp.ok) {
            const data = await resp.json();
            albumSavedStates[albumId] = data.saved;
            updateAlbumSaveButton(albumId, data.saved);
        }
    } catch (err) {
        console.error('Failed to check album saved:', err);
    }
}

function updateAlbumSaveButton(albumId, isSaved) {
    const icon = document.getElementById(`albumSaveIcon-${albumId}`);
    const btn = document.getElementById(`albumSaveBtn-${albumId}`);
    if (icon) {
        icon.src = isSaved ? '/icon/heart-solid' : '/icon/heart';
    }
    if (btn) {
        btn.title = isSaved ? 'Remove from Library' : 'Save to Library';
        btn.classList.toggle('saved', isSaved);
    }
}

async function toggleAlbumSaved(albumId) {
    const isSaved = albumSavedStates[albumId] || false;
    try {
        const resp = await fetch(`/api/spotify/album/${albumId}/save`, {
            method: isSaved ? 'DELETE' : 'PUT'
        });
        if (resp.ok || resp.status === 204) {
            albumSavedStates[albumId] = !isSaved;
            updateAlbumSaveButton(albumId, !isSaved);
        }
    } catch (err) {
        console.error('Failed to toggle album saved:', err);
    }
}

// Artist detail functions (inline)
async function openArtistDetail(artistId) {
    const browseContent = document.getElementById('spotifyBrowseContent');

    // Save current view to history if we're navigating from another detail view
    if (spotifyDetailView) {
        spotifyDetailHistory.push(spotifyDetailView);
    }

    browseContent.innerHTML = '<div class="spotify-loading">Loading artist...</div>';

    try {
        const [artistResp, albumsResp, topTracksResp] = await Promise.all([
            fetch(`/api/spotify/artist/${artistId}`),
            fetch(`/api/spotify/artist/${artistId}/albums?limit=30`),
            fetch(`/api/spotify/artist/${artistId}/top-tracks`)
        ]);

        if (artistResp.ok && albumsResp.ok && topTracksResp.ok) {
            const artist = await artistResp.json();
            const albumsData = await albumsResp.json();
            const topTracksData = await topTracksResp.json();
            spotifyDetailView = {
                type: 'artist',
                data: {
                    artist,
                    albums: albumsData.items || [],
                    topTracks: topTracksData.tracks || []
                }
            };
            browseContent.innerHTML = renderBrowseContent();
            // Check if artist is followed and update button
            checkArtistFollowing(artistId);
        } else {
            browseContent.innerHTML = '<div class="spotify-error">Failed to load artist</div>';
        }
    } catch (err) {
        console.error('Failed to load artist:', err);
        browseContent.innerHTML = '<div class="spotify-error">Failed to load artist</div>';
    }
}

// Track artist following states
let artistFollowingStates = {};

async function checkArtistFollowing(artistId) {
    try {
        const resp = await fetch(`/api/spotify/artist/${artistId}/following`);
        if (resp.ok) {
            const data = await resp.json();
            artistFollowingStates[artistId] = data.following;
            updateArtistFollowButton(artistId, data.following);
        }
    } catch (err) {
        console.error('Failed to check artist following:', err);
    }
}

function updateArtistFollowButton(artistId, isFollowing) {
    const icon = document.getElementById(`artistFollowIcon-${artistId}`);
    const btn = document.getElementById(`artistFollowBtn-${artistId}`);
    if (icon) {
        icon.src = isFollowing ? '/icon/user-check' : '/icon/user-plus';
    }
    if (btn) {
        btn.title = isFollowing ? 'Unfollow' : 'Follow';
        btn.classList.toggle('following', isFollowing);
    }
}

async function toggleArtistFollow(artistId) {
    const isFollowing = artistFollowingStates[artistId] || false;
    try {
        const resp = await fetch(`/api/spotify/artist/${artistId}/follow`, {
            method: isFollowing ? 'DELETE' : 'PUT'
        });
        if (resp.ok || resp.status === 204) {
            artistFollowingStates[artistId] = !isFollowing;
            updateArtistFollowButton(artistId, !isFollowing);
        }
    } catch (err) {
        console.error('Failed to toggle artist follow:', err);
    }
}

function formatNumber(num) {
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
}

let pendingShufflePlay = false;

async function shufflePlay(uri) {
    try {
        // Always fetch fresh device list before playing
        const devicesResp = await fetch('/api/spotify/devices');
        if (!devicesResp.ok) {
            console.error('Failed to fetch devices');
            return;
        }
        const devices = await devicesResp.json();
        spotifyDevices = devices || [];

        // Check if there's an active device
        const hasActiveDevice = spotifyDevices.some(d => d.is_active);

        if (!hasActiveDevice) {
            // No active device - show device picker with shuffle flag
            pendingPlayUri = uri;
            pendingShufflePlay = true;
            openSpotifyDeviceModal();
            return;
        }

        // Enable shuffle first
        await fetch('/api/spotify/shuffle', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: true })
        });

        // Then play (skip device check since we just checked)
        const resp = await fetch('/api/spotify/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uri: uri })
        });

        if (!resp.ok) {
            const errorText = await resp.text();
            console.error('Shuffle play failed:', errorText);
            return;
        }

        setTimeout(loadSpotifyPlayback, 500);
    } catch (err) {
        console.error('Shuffle play failed:', err);
    }
}

function renderNowPlaying() {
    if (!spotifyPlayback || !spotifyPlayback.item) {
        return `
            <div class="spotify-no-playback">
                <img src="/icon/spotify" class="spotify-no-playback-icon" alt="">
                <p>No active playback</p>
                <p class="spotify-hint">Start playing on any device to see controls here</p>
            </div>`;
    }

    const track = spotifyPlayback.item;
    const album = track.album || {};
    const artists = track.artists ? track.artists.map(a => a.name).join(', ') : '';
    const albumArt = album.images && album.images.length > 0 ? album.images[0].url : '';
    const isPlaying = spotifyPlayback.is_playing;
    const shuffleActive = spotifyPlayback.shuffle_state ? 'active' : '';
    const repeatState = spotifyPlayback.repeat_state || 'off';
    const repeatActive = repeatState !== 'off' ? 'active' : '';
    const volume = spotifyPlayback.device ? spotifyPlayback.device.volume_percent : 50;

    return `
        <div class="spotify-now-playing">
            <div class="spotify-album-art">
                ${albumArt ? `<img src="${albumArt}" alt="${escapeHtml(album.name || '')}">` : '<div class="spotify-no-art"></div>'}
            </div>
            <div class="spotify-track-info">
                <div class="spotify-track-name">${escapeHtml(track.name)}</div>
                <div class="spotify-track-artist">${escapeHtml(artists)}</div>
                <div class="spotify-track-album">${escapeHtml(album.name || '')}</div>
            </div>
            <div class="spotify-progress">
                <span class="spotify-time" id="spotifyCurrentTime">${formatTime(spotifyPlayback.progress_ms || 0)}</span>
                <div class="spotify-progress-bar" onclick="seekSpotify(event)">
                    <div class="spotify-progress-fill" id="spotifyProgressBar"></div>
                </div>
                <span class="spotify-time" id="spotifyTotalTime">${formatTime(track.duration_ms || 0)}</span>
            </div>
            <div class="spotify-controls">
                <button class="spotify-control-btn spotify-secondary ${shuffleActive}" onclick="toggleSpotifyShuffle()">
                    <img src="/icon/shuffle" alt="Shuffle">
                </button>
                <button class="spotify-control-btn" onclick="spotifyPrevious()">
                    <img src="/icon/backward-step" alt="Previous">
                </button>
                <button class="spotify-control-btn spotify-play-btn" onclick="toggleSpotifyPlayback()">
                    <img src="/icon/${isPlaying ? 'pause' : 'play'}" alt="${isPlaying ? 'Pause' : 'Play'}">
                </button>
                <button class="spotify-control-btn" onclick="spotifyNext()">
                    <img src="/icon/forward-step" alt="Next">
                </button>
                <button class="spotify-control-btn spotify-secondary ${repeatActive}" onclick="toggleSpotifyRepeat()">
                    <img src="/icon/repeat" alt="Repeat">
                </button>
            </div>
            <div class="spotify-volume">
                <img src="/icon/${getVolumeIcon(volume)}" class="spotify-volume-icon" alt="Volume" onclick="toggleMute()" style="cursor:pointer">
                <input type="range" class="spotify-volume-slider" min="0" max="100" value="${volume}"
                       oninput="onVolumeInput(this)">
                <span class="spotify-volume-value">${volume}%</span>
            </div>
        </div>`;
}

function renderPlaylists() {
    if (spotifyPlaylists.length === 0) {
        return `<div class="spotify-loading">Loading playlists...</div>`;
    }

    let html = `<div class="spotify-playlists-grid">`;
    spotifyPlaylists.forEach(playlist => {
        const image = playlist.images && playlist.images.length > 0 ? playlist.images[0].url : '';
        html += `
            <div class="spotify-playlist-card" onclick="openPlaylist('${playlist.id}', '${escapeHtml(playlist.name)}')">
                <div class="spotify-playlist-image">
                    ${image ? `<img src="${image}" alt="">` : '<div class="spotify-no-art"></div>'}
                </div>
                <div class="spotify-playlist-name">${escapeHtml(playlist.name)}</div>
                <div class="spotify-playlist-tracks">${playlist.tracks.total} tracks</div>
            </div>`;
    });
    html += `</div>`;
    return html;
}

function renderDevices() {
    if (spotifyDevices.length === 0) {
        return `
            <div class="spotify-no-devices">
                <p>No devices found</p>
                <p class="spotify-hint">Open Spotify on a device to see it here</p>
                <button class="modal-btn secondary" onclick="loadSpotifyDevices(); renderSpotifyContent();">Refresh</button>
            </div>`;
    }

    let html = `<div class="spotify-devices-list">`;
    spotifyDevices.forEach(device => {
        const isActive = device.is_active ? 'active' : '';
        const icon = getDeviceIcon(device.type);
        html += `
            <div class="spotify-device ${isActive}" onclick="transferToDevice('${device.id}')">
                <div class="spotify-device-icon">${icon}</div>
                <div class="spotify-device-info">
                    <div class="spotify-device-name">${escapeHtml(device.name)}</div>
                    <div class="spotify-device-type">${device.type}${device.is_active ? ' - Active' : ''}</div>
                </div>
                ${device.is_active ? '<div class="spotify-device-active-indicator"></div>' : ''}
            </div>`;
    });
    html += `</div>`;
    return html;
}

function getDeviceIcon(type) {
    switch (type.toLowerCase()) {
        case 'computer': return 'ðŸ’»';
        case 'smartphone': return 'ðŸ“±';
        case 'speaker': return 'ðŸ”Š';
        case 'tv': return 'ðŸ“º';
        default: return 'ðŸŽµ';
    }
}

function renderSearch() {
    return `
        <div class="spotify-search">
            <div class="spotify-search-input-wrapper">
                <input type="text" id="spotifySearchInput" class="spotify-search-input"
                       placeholder="Search songs, artists, albums..."
                       onkeydown="if(event.key==='Enter')performSpotifySearch()">
                <button class="spotify-search-btn" onclick="performSpotifySearch()">Search</button>
            </div>
            <div id="spotifySearchResults" class="spotify-search-results"></div>
        </div>`;
}

function toggleSearchClear() {
    const input = document.getElementById('spotifySearchInput');
    const clearBtn = document.getElementById('spotifySearchClear');
    if (clearBtn) {
        clearBtn.style.display = input.value.length > 0 ? 'flex' : 'none';
    }
}

function clearSpotifySearch() {
    const input = document.getElementById('spotifySearchInput');
    if (input) {
        input.value = '';
    }
    toggleSearchClear();
    switchSpotifyBrowseTab('home');
    hideKeyboard();
}

async function performSpotifySearch() {
    const input = document.getElementById('spotifySearchInput');
    const browseContent = document.getElementById('spotifyBrowseContent');
    const query = input.value.trim();

    if (!query) return;

    toggleSearchClear();

    // Deselect tabs when searching
    document.querySelectorAll('.spotify-browse-tab').forEach(btn => btn.classList.remove('active'));
    browseContent.innerHTML = '<div class="spotify-loading">Searching...</div>';

    try {
        const resp = await fetch(`/api/spotify/search?q=${encodeURIComponent(query)}&type=track,artist,album,playlist&limit=10`);
        if (resp.ok) {
            const results = await resp.json();
            renderSearchResults(results, browseContent);
        }
    } catch (err) {
        browseContent.innerHTML = '<div class="spotify-error">Search failed</div>';
    }
}

function renderSearchResults(results, container) {
    let html = '<div class="spotify-search-results-container">';

    const tracks = results.tracks?.items || [];
    const artists = results.artists?.items || [];
    const albums = results.albums?.items || [];
    const playlists = (results.playlists?.items || []).filter(p => p);

    // Determine top result (prefer artist match, then album, then track)
    let topResult = null;
    if (artists.length > 0) {
        topResult = { type: 'artist', data: artists[0] };
    } else if (albums.length > 0) {
        topResult = { type: 'album', data: albums[0] };
    } else if (tracks.length > 0) {
        topResult = { type: 'track', data: tracks[0] };
    }

    // Top Result + Songs row
    if (topResult || tracks.length > 0) {
        html += '<div class="spotify-search-top-row">';

        // Top Result
        if (topResult) {
            html += '<div class="spotify-top-result">';
            html += '<h4 class="spotify-search-section-title">Top result</h4>';
            html += renderTopResultCard(topResult);
            html += '</div>';
        }

        // Songs
        if (tracks.length > 0) {
            html += '<div class="spotify-search-songs">';
            html += '<h4 class="spotify-search-section-title">Songs</h4>';
            html += '<div class="spotify-search-songs-list">';
            tracks.slice(0, 4).forEach(track => {
                const artists = track.artists?.map(a => a.name).join(', ') || '';
                const albumArt = track.album?.images?.[track.album.images.length - 1]?.url || '';
                html += `
                    <div class="spotify-search-song-row" onclick="playSpotifyUri('${track.uri}')">
                        <div class="spotify-search-song-thumb">
                            ${albumArt ? `<img src="${albumArt}" alt="">` : ''}
                        </div>
                        <div class="spotify-search-song-info">
                            <div class="spotify-search-song-title">${escapeHtml(track.name)}</div>
                            <div class="spotify-search-song-artist">${escapeHtml(artists)}</div>
                        </div>
                        <div class="spotify-search-song-duration">${formatTime(track.duration_ms)}</div>
                    </div>`;
            });
            html += '</div></div>';
        }

        html += '</div>';
    }

    // Artists row
    if (artists.length > 0) {
        html += '<div class="spotify-search-section">';
        html += '<h4 class="spotify-search-section-title">Artists</h4>';
        html += '<div class="spotify-search-row">';
        artists.slice(0, 7).forEach(artist => {
            const image = artist.images?.[0]?.url || '';
            html += `
                <div class="spotify-search-card spotify-search-card-round" onclick="openArtistDetail('${artist.id}')">
                    <div class="spotify-search-card-img">
                        ${image ? `<img src="${image}" alt="">` : '<div class="spotify-search-card-placeholder"></div>'}
                    </div>
                    <div class="spotify-search-card-name">${escapeHtml(artist.name)}</div>
                    <div class="spotify-search-card-type">Artist</div>
                </div>`;
        });
        html += '</div></div>';
    }

    // Albums row
    if (albums.length > 0) {
        html += '<div class="spotify-search-section">';
        html += '<h4 class="spotify-search-section-title">Albums</h4>';
        html += '<div class="spotify-search-row">';
        albums.slice(0, 7).forEach(album => {
            const image = album.images?.[0]?.url || '';
            const artistName = album.artists?.[0]?.name || '';
            html += `
                <div class="spotify-search-card" onclick="openAlbumDetail('${album.id}')">
                    <div class="spotify-search-card-img">
                        ${image ? `<img src="${image}" alt="">` : '<div class="spotify-search-card-placeholder"></div>'}
                    </div>
                    <div class="spotify-search-card-name">${escapeHtml(album.name)}</div>
                    <div class="spotify-search-card-type">${escapeHtml(artistName)}</div>
                </div>`;
        });
        html += '</div></div>';
    }

    // Playlists row
    if (playlists.length > 0) {
        html += '<div class="spotify-search-section">';
        html += '<h4 class="spotify-search-section-title">Playlists</h4>';
        html += '<div class="spotify-search-row">';
        playlists.slice(0, 7).forEach(playlist => {
            const image = playlist.images?.[0]?.url || '';
            html += `
                <div class="spotify-search-card" onclick="openPlaylist('${playlist.id}', '${escapeHtml(playlist.name).replace(/'/g, "\\'")}')">
                    <div class="spotify-search-card-img">
                        ${image ? `<img src="${image}" alt="">` : '<div class="spotify-search-card-placeholder"></div>'}
                    </div>
                    <div class="spotify-search-card-name">${escapeHtml(playlist.name)}</div>
                    <div class="spotify-search-card-type">By ${escapeHtml(playlist.owner?.display_name || 'Spotify')}</div>
                </div>`;
        });
        html += '</div></div>';
    }

    html += '</div>';

    if (html === '<div class="spotify-search-results-container"></div>') {
        html = '<div class="spotify-no-results">No results found</div>';
    }

    container.innerHTML = html;
}

function renderTopResultCard(topResult) {
    const { type, data } = topResult;
    let image = '';
    let name = '';
    let subtitle = '';
    let onclick = '';

    if (type === 'artist') {
        image = data.images?.[0]?.url || '';
        name = data.name;
        subtitle = 'Artist';
        onclick = `openArtistDetail('${data.id}')`;
    } else if (type === 'album') {
        image = data.images?.[0]?.url || '';
        name = data.name;
        subtitle = data.artists?.[0]?.name || 'Album';
        onclick = `openAlbumDetail('${data.id}')`;
    } else if (type === 'track') {
        image = data.album?.images?.[0]?.url || '';
        name = data.name;
        subtitle = data.artists?.map(a => a.name).join(', ') || '';
        onclick = `playSpotifyUri('${data.uri}')`;
    }

    const isRound = type === 'artist';

    return `
        <div class="spotify-top-result-card ${isRound ? 'round' : ''}" onclick="${onclick}">
            <div class="spotify-top-result-img ${isRound ? 'round' : ''}">
                ${image ? `<img src="${image}" alt="">` : '<div class="spotify-top-result-placeholder"></div>'}
            </div>
            <div class="spotify-top-result-name">${escapeHtml(name)}</div>
            <div class="spotify-top-result-type">${escapeHtml(subtitle)}</div>
        </div>`;
}

function switchSpotifyTab(tabId) {
    activeSpotifyTab = tabId;
    renderSpotifyContent();
}

// Playback controls
async function toggleSpotifyPlayback() {
    const endpoint = spotifyPlayback && spotifyPlayback.is_playing ? '/api/spotify/pause' : '/api/spotify/play';
    const deviceId = spotifyPlayback?.device?.id || '';
    try {
        const resp = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ device_id: deviceId })
        });
        if (!resp.ok) {
            const text = await resp.text();
            console.error('Playback toggle failed:', resp.status, text);
        }
        setTimeout(loadSpotifyPlayback, 300);
    } catch (err) {
        console.error('Playback toggle failed:', err);
    }
}

async function spotifyNext() {
    try {
        const deviceId = spotifyPlayback?.device?.id || '';
        const resp = await fetch('/api/spotify/next', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ device_id: deviceId })
        });
        if (!resp.ok) {
            const text = await resp.text();
            console.error('Next failed:', resp.status, text);
        }
        // Poll a few times to catch the track change
        setTimeout(loadSpotifyPlayback, 300);
        setTimeout(loadSpotifyPlayback, 800);
        setTimeout(loadSpotifyPlayback, 1500);
    } catch (err) {
        console.error('Next failed:', err);
    }
}

async function spotifyPrevious() {
    try {
        const deviceId = spotifyPlayback?.device?.id || '';
        const resp = await fetch('/api/spotify/previous', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ device_id: deviceId })
        });
        if (!resp.ok) {
            const text = await resp.text();
            console.error('Previous failed:', resp.status, text);
        }
        // Poll a few times to catch the track change
        setTimeout(loadSpotifyPlayback, 300);
        setTimeout(loadSpotifyPlayback, 800);
        setTimeout(loadSpotifyPlayback, 1500);
    } catch (err) {
        console.error('Previous failed:', err);
    }
}

let volumeDebounceTimeout = null;
let isAdjustingVolume = false;
let preMuteVolume = 50; // Store volume before muting
let isMuted = false; // Track explicit mute state

function getVolumeIcon(volume) {
    if (isMuted) return 'volume-mute';
    if (volume === 0) return 'volume-off';
    if (volume < 50) return 'volume-low';
    return 'volume-high';
}

function updateVolumeIcons(volume) {
    const icon = getVolumeIcon(volume);
    document.querySelectorAll('.spotify-volume-icon, .spotify-mini-volume-icon').forEach(img => {
        img.src = `/icon/${icon}`;
    });
}

async function toggleMute() {
    if (!spotifyPlayback || !spotifyPlayback.device) return;

    if (!isMuted) {
        // Mute: save current volume and set to 0
        preMuteVolume = spotifyPlayback.device.volume_percent || 50;
        isMuted = true;
        await setSpotifyVolume(0);
    } else {
        // Unmute: restore previous volume
        isMuted = false;
        await setSpotifyVolume(preMuteVolume || 50);
    }

    // Update all volume sliders and icons
    const newVolume = spotifyPlayback.device.volume_percent;
    document.querySelectorAll('.spotify-volume-slider, .spotify-mini-volume-slider').forEach(slider => {
        slider.value = newVolume;
    });
    document.querySelectorAll('.spotify-volume-value').forEach(el => {
        el.textContent = newVolume + '%';
    });
    updateVolumeIcons(newVolume);
}

function onVolumeInput(slider) {
    // Immediately update UI during drag
    isAdjustingVolume = true;
    const volume = parseInt(slider.value);

    // Clear mute state when user manually adjusts volume
    if (volume > 0) {
        isMuted = false;
    }

    // Update volume display text
    document.querySelectorAll('.spotify-volume-value').forEach(el => {
        el.textContent = volume + '%';
    });

    // Update volume icons
    updateVolumeIcons(volume);

    // Update local state to prevent jumps on next poll
    if (spotifyPlayback && spotifyPlayback.device) {
        spotifyPlayback.device.volume_percent = volume;
    }

    // Debounce the API call - only send when user stops dragging
    if (volumeDebounceTimeout) {
        clearTimeout(volumeDebounceTimeout);
    }

    volumeDebounceTimeout = setTimeout(() => {
        setSpotifyVolume(volume);
    }, 300);
}

async function setSpotifyVolume(volume) {
    try {
        // Update local state
        if (spotifyPlayback && spotifyPlayback.device) {
            spotifyPlayback.device.volume_percent = parseInt(volume);
        }

        await fetch('/api/spotify/volume', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ volume_percent: parseInt(volume) })
        });

        // Keep adjusting flag for a bit to prevent poll overwrite
        setTimeout(() => {
            isAdjustingVolume = false;
        }, 1000);
    } catch (err) {
        console.error('Volume change failed:', err);
        isAdjustingVolume = false;
    }
}

async function toggleSpotifyShuffle() {
    const newState = !spotifyPlayback.shuffle_state;
    try {
        await fetch('/api/spotify/shuffle', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: newState })
        });
        setTimeout(loadSpotifyPlayback, 300);
    } catch (err) {
        console.error('Shuffle toggle failed:', err);
    }
}

async function toggleSpotifyRepeat() {
    const states = ['off', 'context', 'track'];
    const currentIndex = states.indexOf(spotifyPlayback.repeat_state || 'off');
    const newState = states[(currentIndex + 1) % states.length];
    try {
        await fetch('/api/spotify/repeat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: newState })
        });
        setTimeout(loadSpotifyPlayback, 300);
    } catch (err) {
        console.error('Repeat toggle failed:', err);
    }
}

async function seekSpotify(event) {
    if (!spotifyPlayback || !spotifyPlayback.item) return;

    const bar = event.currentTarget;
    const rect = bar.getBoundingClientRect();
    const percent = (event.clientX - rect.left) / rect.width;
    const positionMs = Math.floor(percent * spotifyPlayback.item.duration_ms);

    try {
        await fetch('/api/spotify/seek', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ position_ms: positionMs })
        });
        spotifyPlayback.progress_ms = positionMs;
        updateProgressBar();
    } catch (err) {
        console.error('Seek failed:', err);
    }
}

let pendingPlayUri = null;
let pendingPlayPosition = 0;

async function transferToDevice(deviceId) {
    try {
        const hasPendingPlay = !!pendingPlayUri;

        // Transfer to device - don't auto-play if we have a pending URI to play
        await fetch('/api/spotify/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ device_id: deviceId, play: !hasPendingPlay })
        });

        // If there's a pending play URI, play it after transfer
        if (hasPendingPlay) {
            const uriToPlay = pendingPlayUri;
            const shouldShuffle = pendingShufflePlay;
            const positionToPlay = pendingPlayPosition;
            pendingPlayUri = null;
            pendingShufflePlay = false;
            pendingPlayPosition = 0;

            setTimeout(async () => {
                // Enable shuffle if it was a shuffle play
                if (shouldShuffle) {
                    await fetch('/api/spotify/shuffle', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ state: true })
                    });
                }

                await fetch('/api/spotify/play', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ uri: uriToPlay, device_id: deviceId, position: positionToPlay })
                });
                loadSpotifyDevices();
                loadSpotifyPlayback();
            }, 500);
        } else {
            setTimeout(() => {
                loadSpotifyDevices();
                loadSpotifyPlayback();
            }, 500);
        }
    } catch (err) {
        console.error('Transfer failed:', err);
    }
}

async function playSpotifyUri(uri) {
    try {
        // Always fetch fresh device list before playing
        const devicesResp = await fetch('/api/spotify/devices');
        if (!devicesResp.ok) {
            console.error('Failed to fetch devices');
            return;
        }
        const devices = await devicesResp.json();
        spotifyDevices = devices || [];

        // Check if there's an active device
        const hasActiveDevice = spotifyDevices.some(d => d.is_active);

        if (!hasActiveDevice) {
            // No active device - show device picker
            pendingPlayUri = uri;
            openSpotifyDeviceModal();
            return;
        }

        // Active device exists, proceed with play
        const resp = await fetch('/api/spotify/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uri: uri })
        });

        if (!resp.ok) {
            const errorText = await resp.text();
            console.error('Play failed:', errorText);
            return;
        }

        setTimeout(loadSpotifyPlayback, 500);
    } catch (err) {
        console.error('Play failed:', err);
    }
}

// Play a specific track within an album context (enables next/previous)
async function playAlbumTrack(albumUri, trackPosition) {
    try {
        // Always fetch fresh device list before playing
        const devicesResp = await fetch('/api/spotify/devices');
        if (!devicesResp.ok) {
            console.error('Failed to fetch devices');
            return;
        }
        const devices = await devicesResp.json();
        spotifyDevices = devices || [];

        // Check if there's an active device
        const hasActiveDevice = spotifyDevices.some(d => d.is_active);

        if (!hasActiveDevice) {
            // No active device - show device picker
            pendingPlayUri = albumUri;
            pendingPlayPosition = trackPosition;
            openSpotifyDeviceModal();
            return;
        }

        // Active device exists, proceed with play
        const resp = await fetch('/api/spotify/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uri: albumUri, position: trackPosition })
        });

        if (!resp.ok) {
            const errorText = await resp.text();
            console.error('Play failed:', errorText);
            return;
        }

        setTimeout(loadSpotifyPlayback, 500);
    } catch (err) {
        console.error('Play album track failed:', err);
    }
}

async function openPlaylist(playlistId, name) {
    document.getElementById('spotifyPlaylistTitle').textContent = name;
    document.getElementById('spotifyPlaylistModal').classList.add('active');

    const content = document.getElementById('spotifyPlaylistContent');
    content.innerHTML = '<div class="spotify-loading">Loading tracks...</div>';

    try {
        const resp = await fetch(`/api/spotify/playlist/${playlistId}/tracks?limit=50`);
        if (resp.ok) {
            const data = await resp.json();
            renderPlaylistTracks(data.items, `spotify:playlist:${playlistId}`);
        }
    } catch (err) {
        content.innerHTML = '<div class="spotify-error">Failed to load tracks</div>';
    }
}

function renderPlaylistTracks(tracks, contextUri) {
    const content = document.getElementById('spotifyPlaylistContent');

    let html = `
        <button class="spotify-play-all-btn" onclick="playSpotifyUri('${contextUri}')">
            <img src="/icon/play" alt=""> Play All
        </button>
        <div class="spotify-tracks-list">`;

    tracks.forEach((item, index) => {
        if (!item.track) return;
        const track = item.track;
        const artists = track.artists.map(a => a.name).join(', ');
        const albumArt = track.album.images && track.album.images.length > 0 ? track.album.images[track.album.images.length - 1].url : '';
        html += `
            <div class="spotify-track-row" onclick="playSpotifyUri('${contextUri}', ${index})">
                <div class="spotify-track-thumb">
                    ${albumArt ? `<img src="${albumArt}" alt="">` : ''}
                </div>
                <div class="spotify-track-details">
                    <div class="spotify-track-title">${escapeHtml(track.name)}</div>
                    <div class="spotify-track-subtitle">${escapeHtml(artists)}</div>
                </div>
                <div class="spotify-track-duration">${formatTime(track.duration_ms)}</div>
            </div>`;
    });
    html += `</div>`;
    content.innerHTML = html;
}

function closeSpotifyPlaylistModal() {
    document.getElementById('spotifyPlaylistModal').classList.remove('active');
}

// Initialize Spotify
checkSpotifyStatus();
setInterval(loadSpotifyPlayback, 5000);

// Master progress update - single source of truth for progress_ms increment
let miniPlayerProgressInterval = null;
function startMiniPlayerProgress() {
    if (miniPlayerProgressInterval) return;
    miniPlayerProgressInterval = setInterval(() => {
        if (spotifyPlayback && spotifyPlayback.is_playing) {
            spotifyPlayback.progress_ms += 1000;
            updateMiniPlayerProgress();
            // Also update modal progress bar if modal is open
            const modal = document.getElementById('spotifyModal');
            if (modal && modal.classList.contains('active')) {
                updateProgressBar();
            }
        }
    }, 1000);
}
startMiniPlayerProgress();

// Close modals when clicking outside (on the backdrop)
document.querySelectorAll('.modal').forEach(modal => {
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.classList.remove('active');
        }
    });
});

// ===== Camera/Doorbell WebSocket =====
let ws = null;
let wsReconnectTimer = null;
let cameraModalTimeout = null;

function connectWebSocket() {
    if (ws && ws.readyState === WebSocket.OPEN) return;

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

    ws.onopen = () => {
        console.log('WebSocket connected');
        if (wsReconnectTimer) {
            clearTimeout(wsReconnectTimer);
            wsReconnectTimer = null;
        }
    };

    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'doorbell') {
                showCameraModal(data.payload.camera || 'doorbell');
            }
        } catch (e) {
            console.error('WebSocket message error:', e);
        }
    };

    ws.onclose = () => {
        console.log('WebSocket disconnected');
        // Reconnect after 5 seconds
        wsReconnectTimer = setTimeout(connectWebSocket, 5000);
    };

    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
    };
}

function showCameraModal(cameraName) {
    // Dismiss screensaver if active (doorbell takes priority)
    if (window.dismissScreensaver) {
        window.dismissScreensaver();
    }

    const modal = document.getElementById('cameraModal');
    const title = document.getElementById('cameraModalTitle');
    const stream = document.getElementById('cameraStream');

    title.textContent = 'Doorbell';

    // Use snapshot first, then try stream
    stream.src = `/api/camera/${cameraName}/stream`;
    stream.onerror = () => {
        stream.src = `/api/camera/${cameraName}/snapshot`;
    };

    modal.classList.add('active');

    // Play doorbell sound
    playDoorbellSound();

    // Auto-close after 60 seconds
    if (cameraModalTimeout) {
        clearTimeout(cameraModalTimeout);
    }
    cameraModalTimeout = setTimeout(() => {
        closeCameraModal();
    }, 60000);
}

function closeCameraModal() {
    const modal = document.getElementById('cameraModal');
    const stream = document.getElementById('cameraStream');

    modal.classList.remove('active');
    stream.src = '';

    if (cameraModalTimeout) {
        clearTimeout(cameraModalTimeout);
        cameraModalTimeout = null;
    }
}

// Global AudioContext - needs user interaction to work
let doorbellAudioCtx = null;
let audioEnabled = false;

// Initialize audio context on first user interaction
function initAudioContext() {
    if (audioEnabled) return;

    if (!doorbellAudioCtx) {
        doorbellAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        console.log('AudioContext initialized, state:', doorbellAudioCtx.state);
    }
    if (doorbellAudioCtx.state === 'suspended') {
        doorbellAudioCtx.resume().then(() => {
            console.log('AudioContext resumed');
        });
    }

    audioEnabled = true;
}

// Warm up audio on any user interaction
document.addEventListener('click', initAudioContext, { once: true });
document.addEventListener('touchstart', initAudioContext, { once: true });

function playDoorbellSound() {
    console.log('playDoorbellSound called');

    // Create AudioContext if needed
    if (!doorbellAudioCtx) {
        doorbellAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Resume if suspended (browser autoplay policy)
    if (doorbellAudioCtx.state === 'suspended') {
        console.log('AudioContext suspended, attempting resume...');
        doorbellAudioCtx.resume();
    }

    try {
        const ctx = doorbellAudioCtx;

        // First ding - higher pitch
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.connect(gain1);
        gain1.connect(ctx.destination);
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(932, ctx.currentTime); // Bb5
        gain1.gain.setValueAtTime(0.6, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.8);
        osc1.start(ctx.currentTime);
        osc1.stop(ctx.currentTime + 0.8);

        // Second ding - lower pitch (classic ding-dong)
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(698, ctx.currentTime + 0.3); // F5
        gain2.gain.setValueAtTime(0, ctx.currentTime);
        gain2.gain.setValueAtTime(0.6, ctx.currentTime + 0.3);
        gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.2);
        osc2.start(ctx.currentTime + 0.3);
        osc2.stop(ctx.currentTime + 1.2);

        console.log('Doorbell sound playing, ctx state:', ctx.state);
    } catch (e) {
        console.error('Could not play doorbell sound:', e);
    }
}

// Connect WebSocket on page load
document.addEventListener('DOMContentLoaded', () => {
    connectWebSocket();
});
</script>

<!-- Camera Modal -->
<div id="cameraModal" class="modal camera-modal">
    <div class="modal-content modal-camera">
        <div class="modal-header-row">
            <div class="modal-header-title">
                <span class="camera-modal-icon">ðŸ””</span>
                <h3 id="cameraModalTitle">Doorbell</h3>
            </div>
            <button class="modal-close-btn" onclick="closeCameraModal()">&times;</button>
        </div>
        <div class="camera-stream-container">
            <img id="cameraStream" class="camera-stream" alt="Camera stream">
            <div class="camera-loading">Loading camera...</div>
        </div>
        <div class="camera-modal-actions">
            <button class="modal-btn secondary" onclick="closeCameraModal()">Dismiss</button>
        </div>
    </div>
</div>

<!-- Spotify Mini Player Banner -->
<div id="spotifyMiniPlayer" class="spotify-mini-player" style="display: none;" onclick="handleMiniPlayerClick(event)">
    <div class="spotify-mini-art" id="spotifyMiniArt"></div>
    <div class="spotify-mini-info" id="spotifyMiniInfo">
        <div class="spotify-mini-track">Not playing</div>
        <div class="spotify-mini-artist"></div>
    </div>
    <div class="spotify-mini-controls">
        <button class="spotify-mini-btn" onclick="event.stopPropagation(); spotifyPrevious();">
            <img src="/icon/backward-step" alt="Previous">
        </button>
        <button class="spotify-mini-btn spotify-mini-play" id="spotifyMiniPlayBtn" onclick="event.stopPropagation(); toggleSpotifyPlayback();">
            <img src="/icon/play" alt="Play" id="spotifyMiniPlayIcon">
        </button>
        <button class="spotify-mini-btn" onclick="event.stopPropagation(); spotifyNext();">
            <img src="/icon/forward-step" alt="Next">
        </button>
    </div>
    <div class="spotify-mini-volume" onclick="event.stopPropagation();">
        <img src="/icon/volume-high" class="spotify-mini-volume-icon" id="spotifyMiniVolumeIcon" alt="Volume" onclick="toggleMute()" style="cursor:pointer">
        <input type="range" class="spotify-mini-volume-slider" id="spotifyMiniVolumeSlider" min="0" max="100" value="50"
               oninput="onVolumeInput(this)">
    </div>
    <button class="spotify-mini-device-btn" id="spotifyMiniDeviceBtn" onclick="event.stopPropagation(); openSpotifyDeviceModal();">
        <img src="/icon/speaker" alt="Device">
        <span id="spotifyMiniDeviceName">No device</span>
    </button>
    <div class="spotify-mini-progress">
        <div class="spotify-mini-progress-fill" id="spotifyMiniProgressFill"></div>
    </div>
</div>

<!-- Screensaver Overlay -->
<div id="screensaver" class="screensaver">
    <div class="screensaver-bg"></div>
    <div class="screensaver-bg screensaver-bg-next"></div>
    <div class="screensaver-clock">
        <div class="screensaver-time" id="screensaverTime">12:00</div>
        <div class="screensaver-date" id="screensaverDate">Monday, January 1</div>
    </div>
    <div class="screensaver-spotify" id="screensaverSpotify" style="display: none;">
        <img src="/icon/spotify" class="screensaver-spotify-icon" alt="">
        <div class="screensaver-spotify-art" id="screensaverSpotifyArt"></div>
        <div class="screensaver-spotify-info">
            <div class="screensaver-spotify-track" id="screensaverSpotifyTrack"></div>
            <div class="screensaver-spotify-artist" id="screensaverSpotifyArtist"></div>
        </div>
    </div>
</div>

<!-- Background Image Container -->
<div id="pageBackground" class="page-background"></div>

<!-- Settings Module -->
<script src="/static/js/settings.js"></script>
<!-- Screensaver Module -->
<script src="/static/js/screensaver.js"></script>
{{end}}
